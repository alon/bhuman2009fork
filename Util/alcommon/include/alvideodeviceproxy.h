/**
 * This file was generated by ALProxyGenerator
 */

#ifndef ALVIDEODEVICEPROXY_H_
# define ALVIDEODEVICEPROXY_H_
# include "alproxy.h"
# include "alvideodeviceproxyposthandler.h"

namespace AL
{
  /**
   * ALVideoDeviceProxy gives acces to all bound methods of the module.
   */
  class ALVideoDeviceProxy : public ALProxy
    {
       public:

       /**
        * Local Constructor
        */
       ALVideoDeviceProxy(ALPtr<ALBroker> pBroker) : ALProxy(pBroker, "ALVideoDevice")
       { post.setParent( (ALProxy*)this );}

       /**
        * Remote Constructor
        */
       ALVideoDeviceProxy(std::string pIP, int pPort) : ALProxy("ALVideoDevice", pIP, pPort)
       { post.setParent( (ALProxy*)this );}

       /**
        * \brief: Implements thread wrappers around methods
       */
       ALVideoDeviceProxyPostHandler post;

       /**
        * \brief dataChanged : Called by ALMemory when subscribed data has been modified.
        * \param dataName Name of the modified data
        * \param value value of the data
        * \param message associate message.
        */
       void dataChanged ( std::string dataName, ALValue value, std::string message )
       {
         callVoid( "dataChanged", dataName, value, message );
       }

       /**
        * \brief exit : Exit and unregister module, with no params and no return value.
        */
       void exit (  )
       {
         callVoid( "exit" );
       }

       /**
        * \brief getAngPosFromImgPos : Returns angles relative to camera axis given a normalized position in the image.
        * \param pImgPos normalized position in the image [0.0 - 1.0]
        * \return pAngPos : corresponding angles values in radians.
        */
       std::vector<float>  getAngPosFromImgPos ( std::vector<float>  pImgPos )
       {
         return call<std::vector<float> >( "getAngPosFromImgPos", pImgPos );
       }

       /**
        * \brief getAngSizeFromImgSize : Returns angles relative to camera axis given a normalized position in the image.
        * \param pImgSize normalized position in the image [0.0 - 1.0]
        * \return pAngSize : corresponding angles values in radians.
        */
       std::vector<float>  getAngSizeFromImgSize ( std::vector<float>  pImgSize )
       {
         return call<std::vector<float> >( "getAngSizeFromImgSize", pImgSize );
       }

       /**
        * \brief getBrokerName : return the broker name
        * \return broker name : string that contain broker name
        */
       std::string getBrokerName (  )
       {
         return call<std::string>( "getBrokerName" );
       }

       /**
        * \brief getDirectRawImageLocal : Returns a pointer to a locked ALImage, with data array pointing directly to raw data. No format conversion and no copy of the raw buffer.
  When image is not necessary anymore, a call to releaseDirectRawImage() is requested.
  Warning: 1. when using this mode for several G.V.M., if they need raw data for more than 25ms check that you have strictly less G.V.M. modules in this mode than the amount of kernel buffers!! 2. Release all kernel buffers before any action requesting a modification in camera running mode (e.g. resolution, switch between cameras). 
        * \param pId Name under which the G.V.M. is known from the V.I.M.
        * \return pImagePointer : Pointer to the locked image buffer, NULL if error. Warning, image pointer is valid only for C++ dynamic library.
        */
       int getDirectRawImageLocal ( std::string pId )
       {
         return call<int>( "getDirectRawImageLocal", pId );
       }

       /**
        * \brief getDirectRawImageRemote : Fills pFrameOut with data coming directly from raw buffer (no format conversion).
  No need to call releaseDirectRawImage() because it is done automatically at the end of data transmission.
        * \param pId Name under which the G.V.M. is known from the V.I.M.
        * \return imageStructure : Array containing image informations : 
    [0] : width;
    [1] : height;
    [2] : number of layers;
    [3] : ColorSpace;
    [4] : time stamp (highest 32 bits);
    [5] : time stamp (lowest 32 bits);
    [6] : array of size height * width * nblayers containing image data;
        */
       ALValue getDirectRawImageRemote ( std::string pId )
       {
         return call<ALValue>( "getDirectRawImageRemote", pId );
       }

       /**
        * \brief getGVMColorSpace : Get the color space of the requested G.V.M.
        * \param pId Name under which the G.V.M. is known from the V.I.M.
        * \return pColorSpace :  { 0 = kYuv, 9 = kYUV422, 10 = kYUV, 11 = kRGB, 12 = kHSY, 13 = kBGR } -1: can't access video source
        */
       int getGVMColorSpace ( std::string pId )
       {
         return call<int>( "getGVMColorSpace", pId );
       }

       /**
        * \brief getGVMFrameRate : Get the frame rate of the requested G.V.M.
        * \param pId Name under which the G.V.M. is known from the V.I.M.
        * \return pFrameRate :  { 5, 10, 15, 30 }  -1: can't access video source
        */
       int getGVMFrameRate ( std::string pId )
       {
         return call<int>( "getGVMFrameRate", pId );
       }

       /**
        * \brief getGVMResolution : Get the resolution of the requested G.V.M.
        * \param pId Name under which the G.V.M. is known from the V.I.M.
        * \return pSize :  { 0 = kQQVGA, 1 = kQVGA, 2 = kVGA }  -1: can't access video source
        */
       int getGVMResolution ( std::string pId )
       {
         return call<int>( "getGVMResolution", pId );
       }

       /**
        * \brief getImageLocal : Applies transformations to the last image from video source and returns a pointer to a locked ALImage.
  When image is not necessary anymore, a call to releaseImage() is requested.
  If the G.V.M. didn't release preceding image, returns NULL.
        * \param pId Name under which the G.V.M. is known from the V.I.M.
        * \return pImagePointer : Pointer of the locked image buffer, NULL if error. Warning, image pointer is valid only for C++ dynamic library.
        */
       int getImageLocal ( std::string pId )
       {
         return call<int>( "getImageLocal", pId );
       }

       /**
        * \brief getImageRemote : Applies transformations to the last image from video source and fills pFrameOut.
  No need to call releaseImage() because it is done automatically at the end of data transmission.
        * \param pId Name under which the G.V.M. is known from the V.I.M.
        * \return imageStructure : Array containing image informations : 
    [0] : width;
    [1] : height;
    [2] : number of layers;
    [3] : ColorSpace;
    [4] : time stamp (highest 32 bits);
    [5] : time stamp (lowest 32 bits);
    [6] : array of size height * width * nblayers containing image data;
        */
       ALValue getImageRemote ( std::string pId )
       {
         return call<ALValue>( "getImageRemote", pId );
       }

       /**
        * \brief getImgInfoFromAngInfo : Returns normalized image info from angles info in radians (as returned by vision extractors).
        * \param pAngles camera angle values in radians.
        * \return pImgPos : corresponding normalized position info.
        */
       std::vector<float>  getImgInfoFromAngInfo ( std::vector<float>  pAngles )
       {
         return call<std::vector<float> >( "getImgInfoFromAngInfo", pAngles );
       }

       /**
        * \brief getImgInfoFromAngInfoWithRes : Returns image info from angles info in radians (as returned by vision extractors). Express image info in the requested resolution.
        * \param pAngInfo camera angle values in radians.
        * \param arg2 arg
        * \return pImgInfo : corresponding position info.
        */
       std::vector<float>  getImgInfoFromAngInfoWithRes ( std::vector<float>  pAngInfo, int arg2 )
       {
         return call<std::vector<float> >( "getImgInfoFromAngInfoWithRes", pAngInfo, arg2 );
       }

       /**
        * \brief getImgPosFromAngPos : Returns normalized image position from camera angles in radians.
        * \param pAngPos camera angle values in radians.
        * \return pImgPos : corresponding normalized position in the image [0.0 - 1.0]
        */
       std::vector<float>  getImgPosFromAngPos ( std::vector<float>  pAngPos )
       {
         return call<std::vector<float> >( "getImgPosFromAngPos", pAngPos );
       }

       /**
        * \brief getImgSizeFromAngSize : Returns normalized image position from camera angles in radians.
        * \param pAngSize camera angle values in radians.
        * \return pImgSize : corresponding normalized position in the image [0.0 - 1.0]
        */
       std::vector<float>  getImgSizeFromAngSize ( std::vector<float>  pAngSize )
       {
         return call<std::vector<float> >( "getImgSizeFromAngSize", pAngSize );
       }

       /**
        * \brief getMethodHelp : Retrieve a method's description
        * \param methodName the name of the method
        * \return getMethodHelp : a structure containing the method description
        */
       ALValue getMethodHelp ( std::string methodName )
       {
         return call<ALValue>( "getMethodHelp", methodName );
       }

       /**
        * \brief getMethodList : Retrieve the module's method list.
        * \return methodList : an array containing methods name.
        */
       std::vector<std::string>  getMethodList (  )
       {
         return call<std::vector<std::string> >( "getMethodList" );
       }

       /**
        * \brief getParam : Get the value of a video source specific parameter.
        * \param pParam Parameter's reference among kCameraBrightnessID,
 kCameraContrastID,
 kCameraSaturationID,
 kCameraHueID,
 kCameraRedChromaID,
 kCameraBlueChromaID,
 kCameraGainID,
 kCameraHFlipID,
 kCameraVFlipID,
 kCameraLensXID,
 kCameraLensYID,
 kCameraAutoExpositionID,
 kCameraAecAlgorithmID [0:average-based; 1:histogram-based],
 kCameraExposureCorrectionID [-6; 6] (correction by n/3 IL, switch automatically in average-based AEC algorithm if n!=0 and back to histogram-based for n=0),
 kCameraExposureID,
 kCameraAutoWhiteBalanceID,
 kCameraAutoGainID,
 kCameraSelectID [0:top camera; 1:bottom camera],
 kCameraResolutionID,
 kCameraFrameRateID,
 kCameraBufferSizeID,
 kCameraFastSwitchID (need both camera to run same format/ parameter value has no signification),
 kCameraSharpnessID (0-1: no sharpness - 2: medium sharpness - 3-5: high sharpness) 
        * \return pVal : Parameter's value.
        */
       int getParam ( int pParam )
       {
         return call<int>( "getParam", pParam );
       }

       /**
        * \brief getVIMColorSpace : Get the color space of the video source image.
        * \return pColorSpace :  { 0 = kYuv, 9 = kYUV422, 10 = kYUV, 11 = kRGB, 12 = kHSY, 13 = kBGR }  -1 can't access video source
        */
       int getVIMColorSpace (  )
       {
         return call<int>( "getVIMColorSpace" );
       }

       /**
        * \brief getVIMFrameRate : Get the frame rate of the video source image.
        * \return pFrameRate :  { 5, 10, 15, 30 }   -1: can't access video source
        */
       int getVIMFrameRate (  )
       {
         return call<int>( "getVIMFrameRate" );
       }

       /**
        * \brief getVIMResolution : Get the resolution of the video source image.
        * \return pSize :  { 0 = kQQVGA, 1 = kQVGA, 2 = kVGA }  -1: can't access video source
        */
       int getVIMResolution (  )
       {
         return call<int>( "getVIMResolution" );
       }

       /**
        * \brief innerTest : Run an internal test to this module.
        * \return Test_return : true if internal tests are ok
        */
       bool innerTest (  )
       {
         return call<bool>( "innerTest" );
       }

       /**
        * \brief isFrameGrabberOff : Ask if the framegrabber is off.
        * \return pSuccess : true if off
        */
       int isFrameGrabberOff (  )
       {
         return call<int>( "isFrameGrabberOff" );
       }

       /**
        * \brief isRunning : return true if method is currently running
        * \param ID ID of the method to wait
        * \return isRunning : True method is currently running
        */
       bool isRunning ( int ID )
       {
         return call<bool>( "isRunning", ID );
       }

       /**
        * \brief moduleHelp : Retrieve the module's description
        * \return moduleHelp : a structure describing the module
        */
       ALValue moduleHelp (  )
       {
         return call<ALValue>( "moduleHelp" );
       }

       /**
        * \brief ping : Just a ping, with no params and returning always true
        * \return alwaysTrue : returns always true
        */
       bool ping (  )
       {
         return call<bool>( "ping" );
       }

       /**
        * \brief recordVideo : BETA - background record of an .arv raw format video from the images processed by a G.V.M.
        * \param pId Name under which the G.V.M. is known from the V.I.M.
        * \param pPath path/name of the video to be recorded
        * \param pTotalNumber number of images to be recorded. 0xFFFFFFFF for "unlimited"
        * \param pPeriod one image recorded every pPeriod images
        * \return pSuccess : true if success
        */
       bool recordVideo ( std::string pId, std::string pPath, int pTotalNumber, int pPeriod )
       {
         return call<bool>( "recordVideo", pId, pPath, pTotalNumber, pPeriod );
       }

       /**
        * \brief releaseDirectRawImage : Release image buffer locked by getDirectRawImageLocal().
  If G.V.M. had no locked image buffer, does nothing.
        * \param pId Name under which the G.V.M. is known from the V.I.M.
        * \return pSuccess : true if success
        */
       int releaseDirectRawImage ( std::string pId )
       {
         return call<int>( "releaseDirectRawImage", pId );
       }

       /**
        * \brief releaseImage : Release image buffer locked by getImageLocal().
  If G.V.M. had no locked image buffer, does nothing.
        * \param pId Name under which the G.V.M. is known from the V.I.M.
        * \return pSuccess : true if success
        */
       int releaseImage ( std::string pId )
       {
         return call<int>( "releaseImage", pId );
       }

       /**
        * \brief resolutionToSizes : return the width and the height of a resolution
        * \param resolution  { 0 = kQQVGA, 1 = kQVGA, 2 = kVGA } 
        * \return size : array of sizes: (return [-1;-1] if the format is invalid)  
    [0] : width;
    [1] : height;
 
        */
       ALValue resolutionToSizes ( int resolution )
       {
         return call<ALValue>( "resolutionToSizes", resolution );
       }

       /**
        * \brief setColorSpace : Set the colorspace of the output image.
        * \param pId Name under which the G.V.M. is known from the V.I.M.
        * \param pColorSpace  { 0 = kYuv, 9 = kYUV422, 10 = kYUV, 11 = kRGB, 12 = kHSY, 13 = kBGR } 
        * \return pSuccess : true if success
        */
       bool setColorSpace ( std::string pId, int pColorSpace )
       {
         return call<bool>( "setColorSpace", pId, pColorSpace );
       }

       /**
        * \brief setFrameRate : Set the required frame rate.
        * \param pId Name under which the G.V.M. is known from the V.I.M.
        * \param frameRate images per seconds { 5, 10, 15, 30 } 
        * \return pSuccess : true if success
        */
       bool setFrameRate ( std::string pId, int frameRate )
       {
         return call<bool>( "setFrameRate", pId, frameRate );
       }

       /**
        * \brief setParam : Sets the value of a specific parameter for the video source.
        * \param pParam Parameter's reference among kCameraBrightnessID,
 kCameraContrastID,
 kCameraSaturationID,
 kCameraHueID,
 kCameraRedChromaID,
 kCameraBlueChromaID,
 kCameraGainID,
 kCameraHFlipID,
 kCameraVFlipID,
 kCameraLensXID,
 kCameraLensYID,
 kCameraAutoExpositionID,
 kCameraAecAlgorithmID [0:average-based; 1:histogram-based],
 kCameraExposureCorrectionID [-6; 6] (correction by n/3 IL, switch automatically in average-based AEC algorithm if n!=0 and back to histogram-based for n=0),
 kCameraExposureID,
 kCameraAutoWhiteBalanceID,
 kCameraAutoGainID,
 kCameraSelectID [0:top camera; 1:bottom camera],
 kCameraResolutionID,
 kCameraFrameRateID,
 kCameraBufferSizeID,
 kCameraFastSwitchID (need both camera to run same format/ parameter value has no signification),
 kCameraSharpnessID (0-1: no sharpness - 2: medium sharpness - 3-5: high sharpness) 
        * \param pNewValue Parameter's new value.
        */
       void setParam ( int pParam, int pNewValue )
       {
         callVoid( "setParam", pParam, pNewValue );
       }

       /**
        * \brief setParamDefault : Sets a specific parameter for the video source at its default value.
        * \param pParam Parameter's reference. 
        */
       void setParamDefault ( int pParam )
       {
         callVoid( "setParamDefault", pParam );
       }

       /**
        * \brief setResolution : Set the size of the output image.
        * \param pId Name under which the G.V.M. is known from the V.I.M.
        * \param pSize  { 0 = kQQVGA, 1 = kQVGA, 2 = kVGA } 
        * \return pSuccess : true if success
        */
       bool setResolution ( std::string pId, int pSize )
       {
         return call<bool>( "setResolution", pId, pSize );
       }

       /**
        * \brief sizesToResolution : return the resolution from sizes
        * \param width width of the image
        * \param height height of the image
        * \return resolution :  { 0 = kQQVGA, 1 = kQVGA, 2 = kVGA }  or -1 if the inputs are invalid
        */
       int sizesToResolution ( int width, int height )
       {
         return call<int>( "sizesToResolution", width, height );
       }

       /**
        * \brief startFrameGrabber : Open and initialize video source device.
        * \return pSuccess : true if success
        */
       int startFrameGrabber (  )
       {
         return call<int>( "startFrameGrabber" );
       }

       /**
        * \brief stopFrameGrabber : Close video source device.
        * \return pSuccess : true if success
        */
       int stopFrameGrabber (  )
       {
         return call<int>( "stopFrameGrabber" );
       }

       /**
        * \brief stopVideo : BETA - stop writing the video sequence
        * \param pId Name under which the G.V.M. is known from the V.I.M.
        * \return pSuccess : true if success
        */
       bool stopVideo ( std::string pId )
       {
         return call<bool>( "stopVideo", pId );
       }

       /**
        * \brief subscribe : Register to the Video Input Module(V.I.M.). When a General Video Module(G.V.M.) registers to the V.I.M., a buffer of the requested image format is added to the buffers list.
  Returns the name under which the G.V.M. is registered to the V.I.M. (usefull when two G.V.M. try to register using the same name
        * \param pGVMname Name of the registering G.V.M.
        * \param pResolution Resolution requested. { 0 = kQQVGA, 1 = kQVGA, 2 = kVGA } 
        * \param pColorSpace Colorspace requested. { 0 = kYuv, 9 = kYUV422, 10 = kYUV, 11 = kRGB, 12 = kHSY, 13 = kBGR } 
        * \param pFps Fps (frames per second) requested. { 5, 10, 15, 30 } 
        * \return pGVMnameId : Name under which the G.V.M. is known from the V.I.M., 0 if failed
        */
       std::string subscribe ( std::string pGVMname, int pResolution, int pColorSpace, int pFps )
       {
         return call<std::string>( "subscribe", pGVMname, pResolution, pColorSpace, pFps );
       }

       /**
        * \brief unsubscribe : Used to unregister a G.V.M. from the V.I.M.
        * \param pId Name under which the G.V.M. is known from the V.I.M.
        */
       void unsubscribe ( std::string pId )
       {
         callVoid( "unsubscribe", pId );
       }

       /**
        * \brief version : Returns the revision of the module.
        * \return version_string : the string containing the version
        */
       std::string version (  )
       {
         return call<std::string>( "version" );
       }

       /**
        * \brief wait : wait end of execution method if method was called with pCall
        * \param ID ID of the method to wait
        * \param timeout timeout of the wait in ms. 0 if no timeout
        * \return timeout : True if wait exit with timeout
        */
       bool wait ( int ID, int timeout )
       {
         return call<bool>( "wait", ID, timeout );
       }

       /**
        * \brief waitMethod : wait end of execution method if method was called with pCall
        * \param name name of the method to wait
        * \param timeout timeout of the wait. 0 if no timeout
        * \return timeout : True if wait exit with timeout
        */
       int waitMethod ( std::string name, int timeout )
       {
         return call<int>( "waitMethod", name, timeout );
       }

    };
};

#endif
