/**
 * This file was generated by ALProxyGenerator
 */

#ifndef ALMOTIONPROXYPOSTHANDLER_H_
# define ALMOTIONPROXYPOSTHANDLER_H_
# include "alproxy.h"
namespace AL
{
  class ALMotionProxy;

  /**
   * ALMotionProxyPostHandler gives acces to all bound methods of the module, using a thread around each call.
   * Long running tasks can be stopped by calling stop(id) with the id returned by the post. 
   */
  class ALMotionProxyPostHandler
    {
       friend class ALMotionProxy;

       protected:
          AL::ALProxy* fParent;

       private:
          void setParent(AL::ALProxy* pParent) { fParent = pParent;}

       public:

       ALMotionProxyPostHandler() : fParent(NULL)
       {}

       /**
        * \brief addTurn : Adds a turn in place walk pattern that could result in several footsteps.
        * \param pAngle Angle to turn in radians e.g. 0.5.
        * \param pNumSamplesPerStep Number of 20ms cycles per step. e.g. 60.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int addTurn ( float pAngle, int pNumSamplesPerStep )
       {
         return fParent->pCall( "addTurn", pAngle, pNumSamplesPerStep );
       }

       /**
        * \brief addWalkArc : Adds a circular walk pattern that could result in several footsteps
        * \param pAngle Angle of the arc of the circle to turn in radians e.g. 0.5.
        * \param pRadius Radius of the circle in meters e.g. 1.5.
        * \param pNumSamplesPerStep Number of 20ms cycles per step. e.g. 60.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int addWalkArc ( float pAngle, float pRadius, int pNumSamplesPerStep )
       {
         return fParent->pCall( "addWalkArc", pAngle, pRadius, pNumSamplesPerStep );
       }

       /**
        * \brief addWalkSideways : Adds a sideways walk pattern that could result in several footsteps.
        * \param pDistance Sideways distance in meters e.g. -0.1.
        * \param pNumSamplesPerStep Number of 20ms cycles per step. e.g. 60.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int addWalkSideways ( float pDistance, int pNumSamplesPerStep )
       {
         return fParent->pCall( "addWalkSideways", pDistance, pNumSamplesPerStep );
       }

       /**
        * \brief addWalkStraight : Adds a straight walk pattern that could result in several forwards or backwards footsteps
        * \param pDistance Distance in meters e.g. 0.1.
        * \param pNumSamplesPerStep Number of 20ms cycles per step. e.g. 60.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int addWalkStraight ( float pDistance, int pNumSamplesPerStep )
       {
         return fParent->pCall( "addWalkStraight", pDistance, pNumSamplesPerStep );
       }

       /**
        * \brief areResourcesAvailable : Returns true if the resources are available.
        * \param pResourceNames A vector of resource names such as joints
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int areResourcesAvailable ( std::vector<std::string>  pResourceNames )
       {
         return fParent->pCall( "areResourcesAvailable", pResourceNames );
       }

       /**
        * \brief changeAngle : Changes the angle of a joint relative to the current angle.
        * \param pJointName Name of the joint. Could be: "HeadYaw", "HeadPitch", "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw", "LHand", "LHipYawPitch", "LHipRoll", "LHipPitch", "LKneePitch", "LAnklePitch", "LAnkleRoll", "RHipYawPitch", "RHipRoll", "RHipPitch", "RKneePitch", "RAnklePitch", "RAnkleRoll", "RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw", "RHand"
        * \param pAngleChange Angle change in radians.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int changeAngle ( std::string pJointName, float pAngleChange )
       {
         return fParent->pCall( "changeAngle", pJointName, pAngleChange );
       }

       /**
        * \brief changeBodyAngles : Changes the angles relative to the current angles of all the joints in the body.
        * \param pAngleChanges Vector of angle changes.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int changeBodyAngles ( std::vector<float>  pAngleChanges )
       {
         return fParent->pCall( "changeBodyAngles", pAngleChanges );
       }

       /**
        * \brief changeChainAngles : Changes the angles of the joints relative to the current angle in the specified chain. The number of angles required depends on the length of the chain.
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \param pAngleChanges Vector of angles changes in radians.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int changeChainAngles ( std::string pChainName, std::vector<float>  pAngleChanges )
       {
         return fParent->pCall( "changeChainAngles", pChainName, pAngleChanges );
       }

       /**
        * \brief changeCom : Changes the position of the Center of Mass relative to the support Leg. Units are meters.
        * \param pXd x component of the COM change.
        * \param pYd y component of the COM change.
        * \param pZd z component of the COM change.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int changeCom ( float pXd, float pYd, float pZd )
       {
         return fParent->pCall( "changeCom", pXd, pYd, pZd );
       }

       /**
        * \brief changePosition : Creates a move of an end effector in cartesian space.
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \param pSpace Task space.
        * \param pPositionChange 6D position change array (xd,yd,zd,wxd,wyd,wzd) in meters and radians
        * \param pAxisMask Axis mask. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both 
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int changePosition ( std::string pChainName, int pSpace, std::vector<float>  pPositionChange, int pAxisMask )
       {
         return fParent->pCall( "changePosition", pChainName, pSpace, pPositionChange, pAxisMask );
       }

       /**
        * \brief clearFootsteps : Removes all pending footsteps from the queue.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int clearFootsteps (  )
       {
         return fParent->pCall( "clearFootsteps" );
       }

       /**
        * \brief closeHand : Closes the hand, then cuts motor current to conserve energy.
        * \param pHandName The name of the hand. Could be: "RHand" or "LHand"
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int closeHand ( std::string pHandName )
       {
         return fParent->pCall( "closeHand", pHandName );
       }

       /**
        * \brief dataChanged : Called by ALMemory when subscribed data has been modified.
        * \param dataName Name of the modified data
        * \param value value of the data
        * \param message associate message.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int dataChanged ( std::string dataName, ALValue value, std::string message )
       {
         return fParent->pCall( "dataChanged", dataName, value, message );
       }

       /**
        * \brief doMove : Interpolates a sequence of timed angles for several motors.
        * \param pJointNames The joint names corresponding to the outer array of angles and times
        * \param pAngles An ALValue matrix of angles in radians corresponding to the times for each motor.
        * \param pTimes An ALValue matrix of times in seconds corresponding to each motor
        * \param pInterpolationType The type of interpolation { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int doMove ( ALValue pJointNames, ALValue pAngles, ALValue pTimes, int pInterpolationType )
       {
         return fParent->pCall( "doMove", pJointNames, pAngles, pTimes, pInterpolationType );
       }

       /**
        * \brief exit : Exit and unregister module, with no params and no return value.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int exit (  )
       {
         return fParent->pCall( "exit" );
       }

       /**
        * \brief getAngle : Gets the sensed angle of the joint
        * \param pJointName Name of the joint. Could be: "HeadYaw", "HeadPitch", "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw", "LHand", "LHipYawPitch", "LHipRoll", "LHipPitch", "LKneePitch", "LAnklePitch", "LAnkleRoll", "RHipYawPitch", "RHipRoll", "RHipPitch", "RKneePitch", "RAnklePitch", "RAnkleRoll", "RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw", "RHand"
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getAngle ( std::string pJointName )
       {
         return fParent->pCall( "getAngle", pJointName );
       }

       /**
        * \brief getAngleError : Gets the error between the command and sensed angle of the joint
        * \param pJointName Name of the joint. Could be: "HeadYaw", "HeadPitch", "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw", "LHand", "LHipYawPitch", "LHipRoll", "LHipPitch", "LKneePitch", "LAnklePitch", "LAnkleRoll", "RHipYawPitch", "RHipRoll", "RHipPitch", "RKneePitch", "RAnklePitch", "RAnkleRoll", "RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw", "RHand"
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getAngleError ( std::string pJointName )
       {
         return fParent->pCall( "getAngleError", pJointName );
       }

       /**
        * \brief getBalanceMode : Gets the balance mode which can be used to change the way nao responds to commands while keeping balance.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getBalanceMode (  )
       {
         return fParent->pCall( "getBalanceMode" );
       }

       /**
        * \brief getBodyAngleErrors : Gets the errors between the command and sensed angles of all the joints in the body, moving clockwise starting with the head chain. See getBodyJointNames()
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getBodyAngleErrors (  )
       {
         return fParent->pCall( "getBodyAngleErrors" );
       }

       /**
        * \brief getBodyAngles : Gets the sensed angles of all the joints in the body, moving clockwise starting with the head chain. See getBodyJointNames()
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getBodyAngles (  )
       {
         return fParent->pCall( "getBodyAngles" );
       }

       /**
        * \brief getBodyCommandAngles : Gets the command angles of all the joints in the body, moving clockwise starting with the head chain. See getBodyJointNames()
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getBodyCommandAngles (  )
       {
         return fParent->pCall( "getBodyCommandAngles" );
       }

       /**
        * \brief getBodyJointNames : Gets the names of all the joints in the body.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getBodyJointNames (  )
       {
         return fParent->pCall( "getBodyJointNames" );
       }

       /**
        * \brief getBodyLimits : Gets the minAngle, maxAngle, and maxChangePerCycle for all the joints in the body, moving clockwise starting with the head chain. See getBodyJointNames()
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getBodyLimits (  )
       {
         return fParent->pCall( "getBodyLimits" );
       }

       /**
        * \brief getBodyStiffnesses : Gets the stiffnesses of all the joints in the body, moving clockwise starting with the head chain. See getBodyJointNames()
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getBodyStiffnesses (  )
       {
         return fParent->pCall( "getBodyStiffnesses" );
       }

       /**
        * \brief getBrokerName : return the broker name
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getBrokerName (  )
       {
         return fParent->pCall( "getBrokerName" );
       }

       /**
        * \brief getChainAngleErrors : Gets the errors between the command and sensed angles of the joints in a chain.
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getChainAngleErrors ( std::string pChainName )
       {
         return fParent->pCall( "getChainAngleErrors", pChainName );
       }

       /**
        * \brief getChainAngles : Gets the sensed angles of the joints in a chain.
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getChainAngles ( std::string pChainName )
       {
         return fParent->pCall( "getChainAngles", pChainName );
       }

       /**
        * \brief getChainCommandAngles : Gets the angles of the joints in the specified chain. The number of angles returned depends on the length of the chain.
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getChainCommandAngles ( std::string pChainName )
       {
         return fParent->pCall( "getChainCommandAngles", pChainName );
       }

       /**
        * \brief getChainLimits : Get the minAngle, maxAngle, and maxChangePerCycle for a given chain in the body.
        * \param pChainName Chain name. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getChainLimits ( std::string pChainName )
       {
         return fParent->pCall( "getChainLimits", pChainName );
       }

       /**
        * \brief getChainStiffnesses : Gets the stiffnesses of all the joints in a chain
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getChainStiffnesses ( std::string pChainName )
       {
         return fParent->pCall( "getChainStiffnesses", pChainName );
       }

       /**
        * \brief getCom : Gets the position of the Center of Mass relative to the support Leg. Units are meters.
        * \param pSpace Task space.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getCom ( int pSpace )
       {
         return fParent->pCall( "getCom", pSpace );
       }

       /**
        * \brief getCommandAngle : Gets the command angle of a joint.
        * \param pJointName Name of the Joint. Could be: "HeadYaw", "HeadPitch", "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw", "LHand", "LHipYawPitch", "LHipRoll", "LHipPitch", "LKneePitch", "LAnklePitch", "LAnkleRoll", "RHipYawPitch", "RHipRoll", "RHipPitch", "RKneePitch", "RAnklePitch", "RAnkleRoll", "RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw", "RHand"
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getCommandAngle ( std::string pJointName )
       {
         return fParent->pCall( "getCommandAngle", pJointName );
       }

       /**
        * \brief getForwardTransform : Gets the forward Homogenous Transform of a Chain relative to the TASK_SPACE.
        * \param pChainName Chain name. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \param pSpace Task space {SPACE_BODY = 0, SPACE_SUPPORT_LEG = 1 }
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getForwardTransform ( std::string pChainName, int pSpace )
       {
         return fParent->pCall( "getForwardTransform", pChainName, pSpace );
       }

       /**
        * \brief getJointLimits : Get the minAngle, maxAngle, and maxChangePerCycle for a given joint in the body.
        * \param pJointName Joint name.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getJointLimits ( std::string pJointName )
       {
         return fParent->pCall( "getJointLimits", pJointName );
       }

       /**
        * \brief getJointSpeedParams : Gets the user parameters for speed and acceleration control.
        * \param pJointName The name of the joint
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getJointSpeedParams ( std::string pJointName )
       {
         return fParent->pCall( "getJointSpeedParams", pJointName );
       }

       /**
        * \brief getJointStiffness : Gets stiffness of a joint
        * \param pJointName Name of the Joint. Could be:"HeadYaw", "HeadPitch", "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw", "LHand", "LHipYawPitch", "LHipRoll", "LHipPitch", "LKneePitch", "LAnklePitch", "LAnkleRoll", "RHipYawPitch", "RHipRoll", "RHipPitch", "RKneePitch", "RAnklePitch", "RAnkleRoll", "RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw", "RHand"
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getJointStiffness ( std::string pJointName )
       {
         return fParent->pCall( "getJointStiffness", pJointName );
       }

       /**
        * \brief getMethodHelp : Retrieve a method's description
        * \param methodName the name of the method
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getMethodHelp ( std::string methodName )
       {
         return fParent->pCall( "getMethodHelp", methodName );
       }

       /**
        * \brief getMethodList : Retrieve the module's method list.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getMethodList (  )
       {
         return fParent->pCall( "getMethodList" );
       }

       /**
        * \brief getPosition : Gets the Position of a Chain relative to the TASK_SPACE.
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \param pSpace Task space {SPACE_BODY = 0, SPACE_SUPPORT_LEG = 1 }
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getPosition ( std::string pChainName, int pSpace )
       {
         return fParent->pCall( "getPosition", pChainName, pSpace );
       }

       /**
        * \brief getRemainingFootStepCount : Get number of remaining footsteps in the current Walk task
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getRemainingFootStepCount (  )
       {
         return fParent->pCall( "getRemainingFootStepCount" );
       }

       /**
        * \brief getSensorPosition : Gets the Position of a Sensor relative to a TASK_SPACE.
        * \param pSensorName Name of the sensor {CameraTop, CameraBottom, MicroFront, MicroRear, MicroLeft, MicroRight} 
        * \param pSpace Task space {SPACE_BODY = 0, SPACE_SUPPORT_LEG = 1 }
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getSensorPosition ( std::string pSensorName, int pSpace )
       {
         return fParent->pCall( "getSensorPosition", pSensorName, pSpace );
       }

       /**
        * \brief getSummary : Returns a string representation of the Model's state
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getSummary (  )
       {
         return fParent->pCall( "getSummary" );
       }

       /**
        * \brief getSupportMode : Gets the support mode.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getSupportMode (  )
       {
         return fParent->pCall( "getSupportMode" );
       }

       /**
        * \brief getTaskList : Gets an ALValue structure describing the tasks in the Task List
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getTaskList (  )
       {
         return fParent->pCall( "getTaskList" );
       }

       /**
        * \brief getVerbosity : Gets the current verbosity level
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getVerbosity (  )
       {
         return fParent->pCall( "getVerbosity" );
       }

       /**
        * \brief getWalkArmsConfig : Gets the parameters that will be used for Arms next time a WalkTask is created.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getWalkArmsConfig (  )
       {
         return fParent->pCall( "getWalkArmsConfig" );
       }

       /**
        * \brief getWalkArmsEnable : Gets if Arms Motions are enabled during the Walk Process.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getWalkArmsEnable (  )
       {
         return fParent->pCall( "getWalkArmsEnable" );
       }

       /**
        * \brief getWalkConfig : Gets the parameters that will be used next time a WalkTask is created.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getWalkConfig (  )
       {
         return fParent->pCall( "getWalkConfig" );
       }

       /**
        * \brief getWalkTrapezoidConfig : Gets the parameters that will be used next time a WalkTask is created.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getWalkTrapezoidConfig (  )
       {
         return fParent->pCall( "getWalkTrapezoidConfig" );
       }

       /**
        * \brief gotoAngle : Interpolates the angle of a joint from the current angles to the target.
        * \param pJointName Name of the Joint. Could be: "HeadYaw", "HeadPitch", "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw", "LHand", "LHipYawPitch", "LHipRoll", "LHipPitch", "LKneePitch", "LAnklePitch", "LAnkleRoll", "RHipYawPitch", "RHipRoll", "RHipPitch", "RKneePitch", "RAnklePitch", "RAnkleRoll", "RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw", "RHand"
        * \param pAngle Target angle of the motor in radians.
        * \param pDuration Duration of interpolation in seconds.
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int gotoAngle ( std::string pJointName, float pAngle, float pDuration, int pInterpolationType )
       {
         return fParent->pCall( "gotoAngle", pJointName, pAngle, pDuration, pInterpolationType );
       }

       /**
        * \brief gotoAngleWithSpeed : Interpolates the angle of a joint from the current angles to the target.
        * \param pJointName Name of the Joint. Could be: "HeadYaw", "HeadPitch", "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw", "LHand", "LHipYawPitch", "LHipRoll", "LHipPitch", "LKneePitch", "LAnklePitch", "LAnkleRoll", "RHipYawPitch", "RHipRoll", "RHipPitch", "RKneePitch", "RAnklePitch", "RAnkleRoll", "RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw", "RHand"
        * \param pAngle Target angle of the motor in radians.
        * \param pSpeedPercent A Percent relative to Max Speed use for this motion {1~100)
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int gotoAngleWithSpeed ( std::string pJointName, float pAngle, int pSpeedPercent, int pInterpolationType )
       {
         return fParent->pCall( "gotoAngleWithSpeed", pJointName, pAngle, pSpeedPercent, pInterpolationType );
       }

       /**
        * \brief gotoAngles : Interpolates a collection of joints from the current angles to the targets using a fixed duration.
        * \param pJointNames Names of the Joints. Could be: "HeadYaw", "HeadPitch", "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw", "LHand", "LHipYawPitch", "LHipRoll", "LHipPitch", "LKneePitch", "LAnklePitch", "LAnkleRoll", "RHipYawPitch", "RHipRoll", "RHipPitch", "RKneePitch", "RAnklePitch", "RAnkleRoll", "RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw", "RHand"
        * \param pTargetAngles Target angles of the motors in radians.
        * \param pDuration The duration of the interpolation in seconds.
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int gotoAngles ( std::vector<std::string>  pJointNames, std::vector<float>  pTargetAngles, float pDuration, int pInterpolationType )
       {
         return fParent->pCall( "gotoAngles", pJointNames, pTargetAngles, pDuration, pInterpolationType );
       }

       /**
        * \brief gotoAnglesWithSpeed : Interpolates a collection of joints from the current angles to the targets using a percentage of max speed.
        * \param pJointNames Names of the Joints. Could be: "HeadYaw", "HeadPitch", "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw", "LHand", "LHipYawPitch", "LHipRoll", "LHipPitch", "LKneePitch", "LAnklePitch", "LAnkleRoll", "RHipYawPitch", "RHipRoll", "RHipPitch", "RKneePitch", "RAnklePitch", "RAnkleRoll", "RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw", "RHand"
        * \param pTargetAngles Target angles of the motors in radians.
        * \param pSpeedPercent A Percent relative to Max Speed use for this motion {1~100)
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int gotoAnglesWithSpeed ( std::vector<std::string>  pJointNames, std::vector<float>  pTargetAngles, int pSpeedPercent, int pInterpolationType )
       {
         return fParent->pCall( "gotoAnglesWithSpeed", pJointNames, pTargetAngles, pSpeedPercent, pInterpolationType );
       }

       /**
        * \brief gotoBodyAngles : Interpolates the angles of the joints in the body from the current position to the target.
        * \param pAngles Target angles in radians of all the motors in the chain.
        * \param pDuration Duration of interpolation in seconds.
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int gotoBodyAngles ( std::vector<float>  pAngles, float pDuration, int pInterpolationType )
       {
         return fParent->pCall( "gotoBodyAngles", pAngles, pDuration, pInterpolationType );
       }

       /**
        * \brief gotoBodyAnglesWithSpeed : Interpolates the angles of the joints in the body from the current position to the target.
        * \param pAngles Target angles in radians of all the motors in the chain.
        * \param pSpeedPercent A Percent relative to Max Speed use for this motion {1~100)
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int gotoBodyAnglesWithSpeed ( std::vector<float>  pAngles, int pSpeedPercent, int pInterpolationType )
       {
         return fParent->pCall( "gotoBodyAnglesWithSpeed", pAngles, pSpeedPercent, pInterpolationType );
       }

       /**
        * \brief gotoBodyStiffness : Function to Set the stiffness of all the motors in the body; {0.0 : No Joint Control (the motor is in break mode) 1.0: Full joint Control (the error between Command and Sensor is as small as possible) }
        * \param pStiffness Stiffness between zero and one
        * \param pDuration Duration of the interpolation in seconds.
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int gotoBodyStiffness ( float pStiffness, float pDuration, int pInterpolationType )
       {
         return fParent->pCall( "gotoBodyStiffness", pStiffness, pDuration, pInterpolationType );
       }

       /**
        * \brief gotoBodyStiffnesses : Interpolates the stiffnesses of all the motors from the cureent stiffnesses to the targets
        * \param pStiffnesses Target stiffnesses. Must be a vector of floats between 0 and 1.
        * \param pDuration Duration of interpolation in seconds.
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int gotoBodyStiffnesses ( std::vector<float>  pStiffnesses, float pDuration, int pInterpolationType )
       {
         return fParent->pCall( "gotoBodyStiffnesses", pStiffnesses, pDuration, pInterpolationType );
       }

       /**
        * \brief gotoChainAngles : Interpolates the angles of the joints in the specified chain from the current angles to the target. The number of angles required depends on the length of the chain.
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \param pAngles Target angles in radians
        * \param pDuration Duration of interpolation in seconds.
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int gotoChainAngles ( std::string pChainName, std::vector<float>  pAngles, float pDuration, int pInterpolationType )
       {
         return fParent->pCall( "gotoChainAngles", pChainName, pAngles, pDuration, pInterpolationType );
       }

       /**
        * \brief gotoChainAnglesWithSpeed : Interpolates the angles of the joints in the specified chain from the current angles to the target. The number of angles required depends on the length of the chain.
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \param pAngles Target angles in radians
        * \param pSpeedPercent A Percent relative to Max Speed use for this motion {1~100)
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int gotoChainAnglesWithSpeed ( std::string pChainName, std::vector<float>  pAngles, int pSpeedPercent, int pInterpolationType )
       {
         return fParent->pCall( "gotoChainAnglesWithSpeed", pChainName, pAngles, pSpeedPercent, pInterpolationType );
       }

       /**
        * \brief gotoChainStiffness : Function to Set the stiffness of all the motors in the chain; {0.0 : No Joint Control (the motor is in break mode) 1.0: Full joint Control (the error between Command and Sensor is as small as possible) }
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \param pStiffness Stiffness between zero and one.
        * \param pDuration Duration of the interpolation in seconds. 
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int gotoChainStiffness ( std::string pChainName, float pStiffness, float pDuration, int pInterpolationType )
       {
         return fParent->pCall( "gotoChainStiffness", pChainName, pStiffness, pDuration, pInterpolationType );
       }

       /**
        * \brief gotoChainStiffnesses : Interpolates the stiffnesses of a chain from the current stiffnesses to the targets.
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \param pStiffnesses Target stiffnesses. Must be a vector of floats between 0 and 1.
        * \param pDuration Duration of interpolation in seconds.
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int gotoChainStiffnesses ( std::string pChainName, std::vector<float>  pStiffnesses, float pDuration, int pInterpolationType )
       {
         return fParent->pCall( "gotoChainStiffnesses", pChainName, pStiffnesses, pDuration, pInterpolationType );
       }

       /**
        * \brief gotoCom : Moves the position of the Center of Mass over time in absolute frame.
        * \param pX x component of the COM target
        * \param pY y component of the COM target
        * \param pZ z component of the COM target
        * \param pDuration Duration of the interpolation in seconds.
        * \param pInterpolationType The type of interpolation { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int gotoCom ( float pX, float pY, float pZ, float pDuration, int pInterpolationType )
       {
         return fParent->pCall( "gotoCom", pX, pY, pZ, pDuration, pInterpolationType );
       }

       /**
        * \brief gotoJointStiffness : Interpolates the stiffness of a joint from the current stiffness to the target.
        * \param pJointName Name of the joint. Could be: "HeadYaw", "HeadPitch", "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw", "LHand", "LHipYawPitch", "LHipRoll", "LHipPitch", "LKneePitch", "LAnklePitch", "LAnkleRoll", "RHipYawPitch", "RHipRoll", "RHipPitch", "RKneePitch", "RAnklePitch", "RAnkleRoll", "RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw", "RHand"
        * \param pStiffness Target stiffness. Must be a float between 0 and 1.
        * \param pDuration Duration of interpolation in seconds.
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int gotoJointStiffness ( std::string pJointName, float pStiffness, float pDuration, int pInterpolationType )
       {
         return fParent->pCall( "gotoJointStiffness", pJointName, pStiffness, pDuration, pInterpolationType );
       }

       /**
        * \brief gotoJointStiffnesses : Interpolates the stiffness of a group of joint from the current stiffness to the target.
        * \param pJointNames A vector containing the names of the joints. Could be: "HeadYaw", "HeadPitch", "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw", "LHand", "LHipYawPitch", "LHipRoll", "LHipPitch", "LKneePitch", "LAnklePitch", "LAnkleRoll", "RHipYawPitch", "RHipRoll", "RHipPitch", "RKneePitch", "RAnklePitch", "RAnkleRoll", "RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw", "RHand"
        * \param pStiffness A vector containing the target stiffnesses. Must be floats between 0 and 1.
        * \param pDuration Duration of interpolation in seconds.
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int gotoJointStiffnesses ( std::vector<std::string>  pJointNames, std::vector<float>  pStiffness, float pDuration, int pInterpolationType )
       {
         return fParent->pCall( "gotoJointStiffnesses", pJointNames, pStiffness, pDuration, pInterpolationType );
       }

       /**
        * \brief gotoPosition : Moves an end-effector to the given position and orientation over time.
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \param pSpace Task space
        * \param pPosition 6D position array (x,y,z,wx,wy,wz) in meters and radians
        * \param pAxisMask Axis mask. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both 
        * \param pDuration Duration of the interpolation in seconds
        * \param pInterpolationType Type of interpolation { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int gotoPosition ( std::string pChainName, int pSpace, std::vector<float>  pPosition, int pAxisMask, float pDuration, int pInterpolationType )
       {
         return fParent->pCall( "gotoPosition", pChainName, pSpace, pPosition, pAxisMask, pDuration, pInterpolationType );
       }

       /**
        * \brief gotoTorsoOrientation : Function to rotate the torso over time in absolute frame.
        * \param pX x component of the torso orientation in radians.
        * \param pY y component of the torso orientation in radians.
        * \param pDuration Duration of the interpolation in seconds.
        * \param pInterpolationType Type of interpolation { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int gotoTorsoOrientation ( float pX, float pY, float pDuration, int pInterpolationType )
       {
         return fParent->pCall( "gotoTorsoOrientation", pX, pY, pDuration, pInterpolationType );
       }

       /**
        * \brief innerTest : Run an internal test to this module.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int innerTest (  )
       {
         return fParent->pCall( "innerTest" );
       }

       /**
        * \brief isRunning : return true if method is currently running
        * \param ID ID of the method to wait
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int isRunning ( int ID )
       {
         return fParent->pCall( "isRunning", ID );
       }

       /**
        * \brief killAll : Kills all tasks.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int killAll (  )
       {
         return fParent->pCall( "killAll" );
       }

       /**
        * \brief killTask : Kills a task.
        * \param pTaskID TaskID of the task you want to kill. The TaskID is returned from any action which was added with a method prefixed with add
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int killTask ( int pTaskID )
       {
         return fParent->pCall( "killTask", pTaskID );
       }

       /**
        * \brief killTasksUsingResources : Kills all tasks that use any of the resources given.
        * \param pResourceNames A vector of resource names such as joints
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int killTasksUsingResources ( std::vector<std::string>  pResourceNames )
       {
         return fParent->pCall( "killTasksUsingResources", pResourceNames );
       }

       /**
        * \brief moduleHelp : Retrieve the module's description
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int moduleHelp (  )
       {
         return fParent->pCall( "moduleHelp" );
       }

       /**
        * \brief openHand : Opens the hand, then cuts motor current to conserve energy.
        * \param pHandName The name of the hand. Could be: "RHand or "LHand"
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int openHand ( std::string pHandName )
       {
         return fParent->pCall( "openHand", pHandName );
       }

       /**
        * \brief ping : Just a ping, with no params and returning always true
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int ping (  )
       {
         return fParent->pCall( "ping" );
       }

       /**
        * \brief setAngle : Sets the angle of a joint.
        * \param pJointName Name of the Joint. Could be: "HeadYaw", "HeadPitch", "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw", "LHand", "LHipYawPitch", "LHipRoll", "LHipPitch", "LKneePitch", "LAnklePitch", "LAnkleRoll", "RHipYawPitch", "RHipRoll", "RHipPitch", "RKneePitch", "RAnklePitch", "RAnkleRoll", "RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw", "RHand"
        * \param pAngle Target angle in radians.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setAngle ( std::string pJointName, float pAngle )
       {
         return fParent->pCall( "setAngle", pJointName, pAngle );
       }

       /**
        * \brief setBalanceMode : Sets the balance mode which can be used to change the way nao responds to commands while keeping balance.
        * \param pBalanceMode Balance mode {BALANCE_MODE_OFF = 0, BALANCE_MODE_AUTO = 1, BALANCE_MODE_COM_CONTROL = 2}
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setBalanceMode ( int pBalanceMode )
       {
         return fParent->pCall( "setBalanceMode", pBalanceMode );
       }

       /**
        * \brief setBodyAngles : Sets the angles of all the joints in the body.
        * \param pAngles Vector of angles in radians for all the joints of all the chains.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setBodyAngles ( std::vector<float>  pAngles )
       {
         return fParent->pCall( "setBodyAngles", pAngles );
       }

       /**
        * \brief setBodyStiffness : Function to set the stiffness of all the motors in the body to the same value; {0.0 : No Joint Control (the motor is in break mode) 1.0: Full joint Control (the error between Command and Sensor is as small as possible) }
        * \param pStiffness Stiffness between zero and one.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setBodyStiffness ( float pStiffness )
       {
         return fParent->pCall( "setBodyStiffness", pStiffness );
       }

       /**
        * \brief setChainAngles : Sets the angles of the joints in the specified chain. The number of angles required depends on the length of the chain.
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \param pAngles Vector of target angles in radians.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setChainAngles ( std::string pChainName, std::vector<float>  pAngles )
       {
         return fParent->pCall( "setChainAngles", pChainName, pAngles );
       }

       /**
        * \brief setChainStiffness : Function to set the stiffness of all the motors in the chain to the same value; {0.0 : No Joint Control (the motor is in break mode) 1.0: Full joint Control (the error between Command and Sensor is as small as possible) }
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \param pStiffness Stiffness between zero and one.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setChainStiffness ( std::string pChainName, float pStiffness )
       {
         return fParent->pCall( "setChainStiffness", pChainName, pStiffness );
       }

       /**
        * \brief setCom : Sets the position of the Center of Mass relative to the support Leg. Units are meters.
        * \param pX x component of the COM position.
        * \param pY y component of the COM position.
        * \param pZ z component of the COM position.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setCom ( float pX, float pY, float pZ )
       {
         return fParent->pCall( "setCom", pX, pY, pZ );
       }

       /**
        * \brief setInertialSensorEnabled : Enables or disables the use of inertial sensor while in BALANCE_MODE_AUTO
        * \param pInertialSensorEnable true if you want motion to use the intertial sensor
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setInertialSensorEnabled ( bool pInertialSensorEnable )
       {
         return fParent->pCall( "setInertialSensorEnabled", pInertialSensorEnable );
       }

       /**
        * \brief setJointSpeedParams : Sets the user parmeters for speed and acceleration control. The default values are the highest that the joint allows. The max acceleration and deceleration cannot be greater than the max speed. Hard joint limits define the max values.
        * \param pJointName The name of the joint
        * \param pUserMaxSpeed The maximum movement in radians per cycle e.g. 0.05
        * \param pUserMaxAcceleration The maximum acceleration in radians per cycle e.g. 0.006
        * \param pUserMaxDecleration The maximum deceleration in radians per cycle e.g. 0.006
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setJointSpeedParams ( std::string pJointName, float pUserMaxSpeed, float pUserMaxAcceleration, float pUserMaxDecleration )
       {
         return fParent->pCall( "setJointSpeedParams", pJointName, pUserMaxSpeed, pUserMaxAcceleration, pUserMaxDecleration );
       }

       /**
        * \brief setJointStiffness : Sets the stiffness of a joint in the body. {0.0 : No Joint Control (the motor is in break mode) 1.0: Full joint Control (the error between Command and Sensor is as small as possible) }
        * \param pJointName Name of the Joint.
        * \param pStiffness Stiffness between zero and one.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setJointStiffness ( std::string pJointName, float pStiffness )
       {
         return fParent->pCall( "setJointStiffness", pJointName, pStiffness );
       }

       /**
        * \brief setJointStiffnesses : Sets the stiffness for a group of named joints {0.0 : No Joint Control (the motor is in break mode) 1.0: Full joint Control (the error between Command and Sensor is as small as possible) }
        * \param pJointNames A vector containing the Names of the Joints.
        * \param pStiffnesses A vector containing the Stiffnesses between zero and one.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setJointStiffnesses ( std::vector<std::string>  pJointNames, std::vector<float>  pStiffnesses )
       {
         return fParent->pCall( "setJointStiffnesses", pJointNames, pStiffnesses );
       }

       /**
        * \brief setPosition : Moves an end-effector to the given position and orientation.
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \param pSpace Task space.
        * \param pPosition 6D position array (x,y,z,wx,wy,wz) in meters and radians
        * \param pAxisMask Axis mask. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both 
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setPosition ( std::string pChainName, int pSpace, std::vector<float>  pPosition, int pAxisMask )
       {
         return fParent->pCall( "setPosition", pChainName, pSpace, pPosition, pAxisMask );
       }

       /**
        * \brief setSupportMode : Sets the support mode.
        * \param pSupportMode Support mode. { SUPPORT_MODE_LEFT = 0, SUPPORT_MODE_DOUBLE_LEFT = 1, SUPPORT_MODE_RIGHT = 2, SUPPORT_MODE_DOUBLE_RIGHT = 3}
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setSupportMode ( int pSupportMode )
       {
         return fParent->pCall( "setSupportMode", pSupportMode );
       }

       /**
        * \brief setTorsoOrientation : Sets the Torso Orientation. Units are radians.
        * \param pTetaX The x component of the Torso Orientation along X Axis
        * \param pTetaY The y component of the Torso Orientation along Y Axis
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setTorsoOrientation ( float pTetaX, float pTetaY )
       {
         return fParent->pCall( "setTorsoOrientation", pTetaX, pTetaY );
       }

       /**
        * \brief setVerbosity : Sets the current verbosity level. A level of 2 and above will allow ALMotion to output positions in space to memory. Default 1
        * \param pVerbosityLevel 0 == LOW, 3 == HIGH
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setVerbosity ( int pVerbosityLevel )
       {
         return fParent->pCall( "setVerbosity", pVerbosityLevel );
       }

       /**
        * \brief setWalkArmsConfig : Sets the parameters that will be used for Arms next time a WalkTask is created.
        * \param pShoulderMedian the Median value of Shoulder Pitch
        * \param pShoulderAmplitude the Median value of Shoulder Pitch
        * \param pElbowMedian the Median value of Elbow Roll
        * \param pElbowAmplitude the Median value of Elbow Roll
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setWalkArmsConfig ( float pShoulderMedian, float pShoulderAmplitude, float pElbowMedian, float pElbowAmplitude )
       {
         return fParent->pCall( "setWalkArmsConfig", pShoulderMedian, pShoulderAmplitude, pElbowMedian, pElbowAmplitude );
       }

       /**
        * \brief setWalkArmsEnable : Sets if Arms Motions are enabled during the Walk Process.
        * \param pArmsEnable if true Arm Motions are controlled by the Walk Task
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setWalkArmsEnable ( bool pArmsEnable )
       {
         return fParent->pCall( "setWalkArmsEnable", pArmsEnable );
       }

       /**
        * \brief setWalkConfig : Sets the parameters that will be used next time a WalkTask is created (Use with caution).
        * \param pMaxStepLength Maximum length in meters of a footstep (0.0 to 0.09 meters).
        * \param pMaxStepHeight Maximum height of a footstep cycloid (0.0 to 0.08 meters).
        * \param pMaxStepSide Maximum side length in meters of a footstep  0.0 to 0.06 meters).
        * \param pMaxStepTurn Maximum change in z orientation in radians of a footstep (0.0 to 1.0 radians).
        * \param pHipHeight Height of the Hip during Walk Process (0.15 to 0.244 meter)
        * \param pTorsoYOrientation Define the Torso Orientation in degrees along Y axis during Walk Process (-10.0 to 10 degrees)
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setWalkConfig ( float pMaxStepLength, float pMaxStepHeight, float pMaxStepSide, float pMaxStepTurn, float pHipHeight, float pTorsoYOrientation )
       {
         return fParent->pCall( "setWalkConfig", pMaxStepLength, pMaxStepHeight, pMaxStepSide, pMaxStepTurn, pHipHeight, pTorsoYOrientation );
       }

       /**
        * \brief setWalkTrapezoidConfig : change parameter of Trapezoid
        * \param pLRollBacklashCompensator Amplitude in degrees of backlash compensation for LHipRoll (0.0 to 10.0 degrees)
        * \param pRRollBacklashCompensator Amplitude in degrees of backlash compensation for RHipRoll (-10.0 to 0.0 degrees)
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setWalkTrapezoidConfig ( float pLRollBacklashCompensator, float pRRollBacklashCompensator )
       {
         return fParent->pCall( "setWalkTrapezoidConfig", pLRollBacklashCompensator, pRRollBacklashCompensator );
       }

       /**
        * \brief stop : Stops a task using the taskID that was returned when creating the task.
        * \param pBrokerTaskID The unique BrokerTaskID that identifies the task.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int stop ( int pBrokerTaskID )
       {
         return fParent->pCall( "stop", pBrokerTaskID );
       }

       /**
        * \brief turn : Does a turn in place walk pattern that could result in several footsteps.
        * \param pAngle Angle to turn in radians e.g. 0.5.
        * \param pNumSamplesPerStep Number of 20ms cycles per step. e.g. 60.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int turn ( float pAngle, int pNumSamplesPerStep )
       {
         return fParent->pCall( "turn", pAngle, pNumSamplesPerStep );
       }

       /**
        * \brief updateInertialSensorOffset : Fixes the offset between the orientation sensed through the joints and the orientation given by the inertial sensor. Should only be used when the feet are flat on the ground.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int updateInertialSensorOffset (  )
       {
         return fParent->pCall( "updateInertialSensorOffset" );
       }

       /**
        * \brief version : Returns the revision of the module.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int version (  )
       {
         return fParent->pCall( "version" );
       }

       /**
        * \brief wait : wait end of execution method if method was called with pCall
        * \param ID ID of the method to wait
        * \param timeout timeout of the wait in ms. 0 if no timeout
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int wait ( int ID, int timeout )
       {
         return fParent->pCall( "wait", ID, timeout );
       }

       /**
        * \brief waitMethod : wait end of execution method if method was called with pCall
        * \param name name of the method to wait
        * \param timeout timeout of the wait. 0 if no timeout
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int waitMethod ( std::string name, int timeout )
       {
         return fParent->pCall( "waitMethod", name, timeout );
       }

       /**
        * \brief waitUntilWalkIsFinished : Waits until the WalkTask is finished.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int waitUntilWalkIsFinished (  )
       {
         return fParent->pCall( "waitUntilWalkIsFinished" );
       }

       /**
        * \brief walk : Walk. Will consume all walk patterns and footsteps.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int walk (  )
       {
         return fParent->pCall( "walk" );
       }

       /**
        * \brief walkArc : Does a circular walk pattern that could result in several footsteps.
        * \param pAngle Angle of the arc of the circle to turn in radians e.g. 0.5.
        * \param pRadius Radius of the circle in meters e.g. 1.5.
        * \param pNumSamplesPerStep Number of 20ms cycles per step. e.g. 60.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int walkArc ( float pAngle, float pRadius, int pNumSamplesPerStep )
       {
         return fParent->pCall( "walkArc", pAngle, pRadius, pNumSamplesPerStep );
       }

       /**
        * \brief walkIsActive : Returns true if there is an active walk task.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int walkIsActive (  )
       {
         return fParent->pCall( "walkIsActive" );
       }

       /**
        * \brief walkSideways : Does a sideways walk pattern that could result in several footsteps.
        * \param pDistance Sideways distance in meters e.g. -0.1.
        * \param pNumSamplesPerStep Number of 20ms cycles per step. e.g. 60.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int walkSideways ( float pDistance, int pNumSamplesPerStep )
       {
         return fParent->pCall( "walkSideways", pDistance, pNumSamplesPerStep );
       }

       /**
        * \brief walkStraight : Does a straight walk pattern that could result in several forwards or backwards footsteps.
        * \param pDistance Distance in meters e.g. 0.1.
        * \param pNumSamplesPerStep Number of 20ms cycles per step. e.g. 60.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int walkStraight ( float pDistance, int pNumSamplesPerStep )
       {
         return fParent->pCall( "walkStraight", pDistance, pNumSamplesPerStep );
       }

    };
};

#endif
