/**
 * This file was generated by ALProxyGenerator
 */

#ifndef ALLOGGERPROXYPOSTHANDLER_H_
# define ALLOGGERPROXYPOSTHANDLER_H_
# include "alproxy.h"
namespace AL
{
  class ALLoggerProxy;

  /**
   * ALLoggerProxyPostHandler gives acces to all bound methods of the module, using a thread around each call.
   * Long running tasks can be stopped by calling stop(id) with the id returned by the post. 
   */
  class ALLoggerProxyPostHandler
    {
       friend class ALLoggerProxy;

       protected:
          AL::ALProxy* fParent;

       private:
          void setParent(AL::ALProxy* pParent) { fParent = pParent;}

       public:

       ALLoggerProxyPostHandler() : fParent(NULL)
       {}

       /**
        * \brief dataChanged : Called by ALMemory when subscribed data has been modified.
        * \param dataName Name of the modified data
        * \param value value of the data
        * \param message associate message.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int dataChanged ( std::string dataName, ALValue value, std::string message )
       {
         return fParent->pCall( "dataChanged", dataName, value, message );
       }

       /**
        * \brief debug : Log a debug message.
        * \param moduleName Name of the module.
        * \param message Log Message.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int debug ( std::string moduleName, std::string message )
       {
         return fParent->pCall( "debug", moduleName, message );
       }

       /**
        * \brief error : Log an error.
        * \param moduleName Name of the module.
        * \param message Log Message.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int error ( std::string moduleName, std::string message )
       {
         return fParent->pCall( "error", moduleName, message );
       }

       /**
        * \brief exit : Exit and unregister module, with no params and no return value.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int exit (  )
       {
         return fParent->pCall( "exit" );
       }

       /**
        * \brief fatal : Log a fatal error.
        * \param moduleName Name of the module.
        * \param message Log Message.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int fatal ( std::string moduleName, std::string message )
       {
         return fParent->pCall( "fatal", moduleName, message );
       }

       /**
        * \brief getBrokerName : return the broker name
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getBrokerName (  )
       {
         return fParent->pCall( "getBrokerName" );
       }

       /**
        * \brief getMethodHelp : Retrieve a method's description
        * \param methodName the name of the method
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getMethodHelp ( std::string methodName )
       {
         return fParent->pCall( "getMethodHelp", methodName );
       }

       /**
        * \brief getMethodList : Retrieve the module's method list.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getMethodList (  )
       {
         return fParent->pCall( "getMethodList" );
       }

       /**
        * \brief info : Log a info message.
        * \param moduleName Name of the module.
        * \param message Log Message.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int info ( std::string moduleName, std::string message )
       {
         return fParent->pCall( "info", moduleName, message );
       }

       /**
        * \brief innerTest : Run an internal test to this module.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int innerTest (  )
       {
         return fParent->pCall( "innerTest" );
       }

       /**
        * \brief isRunning : return true if method is currently running
        * \param ID ID of the method to wait
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int isRunning ( int ID )
       {
         return fParent->pCall( "isRunning", ID );
       }

       /**
        * \brief logInALMemory : Allow logger to store log in the ALMemory.
        * \param pOnOff True to start, false to stop
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int logInALMemory ( bool pOnOff )
       {
         return fParent->pCall( "logInALMemory", pOnOff );
       }

       /**
        * \brief logInFile : Allows the logger to store logs in a file.
        * \param pOnOff True to start, false to stop
        * \param fileName Absolute file name of the output text file. 
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int logInFile ( bool pOnOff, std::string fileName )
       {
         return fParent->pCall( "logInFile", pOnOff, fileName );
       }

       /**
        * \brief logInStd : Allows the logger to output logs to the standard output.
        * \param pOnOff True to start, false to stop
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int logInStd ( bool pOnOff )
       {
         return fParent->pCall( "logInStd", pOnOff );
       }

       /**
        * \brief lowDebug : Log a low priority debug message.
        * \param moduleName Name of the module.
        * \param message Log Message.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int lowDebug ( std::string moduleName, std::string message )
       {
         return fParent->pCall( "lowDebug", moduleName, message );
       }

       /**
        * \brief lowInfo : Log a low priority information message.
        * \param moduleName Name of the module.
        * \param message Log Message.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int lowInfo ( std::string moduleName, std::string message )
       {
         return fParent->pCall( "lowInfo", moduleName, message );
       }

       /**
        * \brief moduleHelp : Retrieve the module's description
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int moduleHelp (  )
       {
         return fParent->pCall( "moduleHelp" );
       }

       /**
        * \brief ping : Just a ping, with no params and returning always true
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int ping (  )
       {
         return fParent->pCall( "ping" );
       }

       /**
        * \brief separator : output a simple line separator
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int separator (  )
       {
         return fParent->pCall( "separator" );
       }

       /**
        * \brief setVerbosity : set verbosity lowDebug (max verbostity), debug, lowInfo, info, warning, error, fatal
        * \param verbosity verbosity value
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setVerbosity ( std::string verbosity )
       {
         return fParent->pCall( "setVerbosity", verbosity );
       }

       /**
        * \brief setVerbosityByModuleName : set verbosity by module
        * \param pModuleName Name of the module
        * \param pVerbosity verbosity level
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setVerbosityByModuleName ( std::string pModuleName, std::string pVerbosity )
       {
         return fParent->pCall( "setVerbosityByModuleName", pModuleName, pVerbosity );
       }

       /**
        * \brief sleep : just sleep an amount of time (for test purpose)
        * \param nTimeInMilliSeconds time to sleep in milli seconds.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int sleep ( int nTimeInMilliSeconds )
       {
         return fParent->pCall( "sleep", nTimeInMilliSeconds );
       }

       /**
        * \brief stop : callback when user call stop(id) on allogger method
        * \param stoppedID function ID allow to deduce function name, module name...
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int stop ( int stoppedID )
       {
         return fParent->pCall( "stop", stoppedID );
       }

       /**
        * \brief testReturnValue : just return the value received (for test purpose)
        * \param arg1 arg
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int testReturnValue ( ALValue arg1 )
       {
         return fParent->pCall( "testReturnValue", arg1 );
       }

       /**
        * \brief version : Returns the revision of the module.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int version (  )
       {
         return fParent->pCall( "version" );
       }

       /**
        * \brief wait : wait end of execution method if method was called with pCall
        * \param ID ID of the method to wait
        * \param timeout timeout of the wait in ms. 0 if no timeout
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int wait ( int ID, int timeout )
       {
         return fParent->pCall( "wait", ID, timeout );
       }

       /**
        * \brief waitMethod : wait end of execution method if method was called with pCall
        * \param name name of the method to wait
        * \param timeout timeout of the wait. 0 if no timeout
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int waitMethod ( std::string name, int timeout )
       {
         return fParent->pCall( "waitMethod", name, timeout );
       }

       /**
        * \brief warn : Log a warning.
        * \param moduleName Name of the module.
        * \param message Log Message.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int warn ( std::string moduleName, std::string message )
       {
         return fParent->pCall( "warn", moduleName, message );
       }

    };
};

#endif
