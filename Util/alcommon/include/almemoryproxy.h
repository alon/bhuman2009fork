/**
 * This file was generated by ALProxyGenerator
 */

#ifndef ALMEMORYPROXY_H_
# define ALMEMORYPROXY_H_
# include "alproxy.h"
# include "almemoryproxyposthandler.h"

#define STMLOGNAME  "/naoqi/log"
#define STMEXCEPTIONNAME  "/naoqi/exception"

// exceptions are visible here
#define STMEXCEPTIONNAME  "/naoqi/exception"
// ALBonjour module add Nao IP, name, port here when a Nao is connected to local network
#define STMDETECTNAOCONNECTION_IP "/albonjour/ip"
#define STMDETECTNAOCONNECTION_NAME "/albonjour/name"
#define STMDETECTNAOCONNECTION_PORT "/albonjour/port"
namespace AL
{
  /**
   * ALMemoryProxy gives acces to all bound methods of the module.
   */
  class ALMemoryProxy : public ALProxy
    {
       public:

       /**
        * Local Constructor
        */
       ALMemoryProxy(ALPtr<ALBroker> pBroker) : ALProxy(pBroker, "ALMemory")
       { post.setParent( (ALProxy*)this );}

       /**
        * Remote Constructor
        */
       ALMemoryProxy(std::string pIP, int pPort) : ALProxy("ALMemory", pIP, pPort)
       { post.setParent( (ALProxy*)this );}

       /**
        * \brief: Implements thread wrappers around methods
       */
       ALMemoryProxyPostHandler post;

       /**
        * \brief dataChanged : Called by ALMemory when subscribed data has been modified.
        * \param dataName Name of the modified data
        * \param value value of the data
        * \param message associate message.
        */
       void dataChanged ( std::string dataName, ALValue value, std::string message )
       {
         callVoid( "dataChanged", dataName, value, message );
       }

       /**
        * \brief exit : Exit and unregister module, with no params and no return value.
        */
       void exit (  )
       {
         callVoid( "exit" );
       }

       /**
        * \brief getBrokerName : return the broker name
        * \return broker name : string that contain broker name
        */
       std::string getBrokerName (  )
       {
         return call<std::string>( "getBrokerName" );
       }

       /**
        * \brief getData : Allows programs and modules to get data stored in ALMemory.
        * \param Name Name of the data.
        * \param duration All the data stored for "duration" seconds will be returned. If 0 returns the lastest value. If -1 returns all stored values.
        * \return value : an array containing all the retrieved data
        */
       ALValue getData ( std::string Name, int duration )
       {
         return call<ALValue>( "getData", Name, duration );
       }

       /**
        * \brief getDataListName : Allows programs to get an array containing all the data's name.
        * \return value : return an array of data's string name.
        */
       ALValue getDataListName (  )
       {
         return call<ALValue>( "getDataListName" );
       }

       /**
        * \brief getDataOnChange : Allows programs and modules to retrieve data stored in ALMemory, but waits until the data has changed.
        * \param Name Name of the data.
        * \param duration All the data stored for "duration" seconds will be returned. If 0 returns the lastest value. If -1 returns all stored values.
        * \return value : an array containing all the retrieved data
        */
       ALValue getDataOnChange ( std::string Name, int duration )
       {
         return call<ALValue>( "getDataOnChange", Name, duration );
       }

       /**
        * \brief getListData : Allows programs and modules to retrieve multiple datas stored in ALMemory at the same time.
        * \param Name an array containing the datas' name and their durations.
        * \return value : an array containing all the retrieved values of requested data
        */
       ALValue getListData ( ALValue Name )
       {
         return call<ALValue>( "getListData", Name );
       }

       /**
        * \brief getMethodHelp : Retrieve a method's description
        * \param methodName the name of the method
        * \return getMethodHelp : a structure containing the method description
        */
       ALValue getMethodHelp ( std::string methodName )
       {
         return call<ALValue>( "getMethodHelp", methodName );
       }

       /**
        * \brief getMethodList : Retrieve the module's method list.
        * \return methodList : an array containing methods name.
        */
       std::vector<std::string>  getMethodList (  )
       {
         return call<std::vector<std::string> >( "getMethodList" );
       }

       /**
        * \brief getValuesPool : Allows optimised internal access to ALMemory. Please do not use.
        * \return value : returns the pointer to the ALMemory
        */
       int getValuesPool (  )
       {
         return call<int>( "getValuesPool" );
       }

       /**
        * \brief innerTest : Run an internal test to this module.
        * \return Test_return : true if internal tests are ok
        */
       bool innerTest (  )
       {
         return call<bool>( "innerTest" );
       }

       /**
        * \brief insertData : Allows any program to insert data into ALMemory.
        * \param Name Name of the data to be inserted.
        * \param Value Value of the data. could be int, double, string, or an array of any of these types.
        * \param lifespan number of data stocked in data historic. When inserting a data, the oldest is erased and leaves its place for the newest
        */
       void insertData ( std::string Name, ALValue Value, int lifespan )
       {
         callVoid( "insertData", Name, Value, lifespan );
       }

       /**
        * \brief insertListData : Allows any program to insert a list of data into ALMemory.
        * \param listOfInsertData list of [Name, Value, lifespan, waitforAnswer, group] for each data to be inserted.
        */
       void insertListData ( ALValue listOfInsertData )
       {
         callVoid( "insertListData", listOfInsertData );
       }

       /**
        * \brief isRunning : return true if method is currently running
        * \param ID ID of the method to wait
        * \return isRunning : True method is currently running
        */
       bool isRunning ( int ID )
       {
         return call<bool>( "isRunning", ID );
       }

       /**
        * \brief moduleHelp : Retrieve the module's description
        * \return moduleHelp : a structure describing the module
        */
       ALValue moduleHelp (  )
       {
         return call<ALValue>( "moduleHelp" );
       }

       /**
        * \brief ping : Just a ping, with no params and returning always true
        * \return alwaysTrue : returns always true
        */
       bool ping (  )
       {
         return call<bool>( "ping" );
       }

       /**
        * \brief removeData : Allows programs and modules to retrieve data stored in ALMemory.
        * \param Name Name of the data to be remove.
        */
       void removeData ( std::string Name )
       {
         callVoid( "removeData", Name );
       }

       /**
        * \brief subscribeOnData : Allows modules to subscribe to a piece of data, in order to get notified when the data changes. Subscribers are called whenever the data has been set, even if the new value is the same as the previous one.
        * \param dataName Name of the data.
        * \param moduleName Name of the module.
        * \param message message passed to the module when a notification is sent.
        * \param callback name of function to call when a data is changed (default is dataChanged)
        */
       void subscribeOnData ( std::string dataName, std::string moduleName, std::string message, std::string callback )
       {
         callVoid( "subscribeOnData", dataName, moduleName, message, callback );
       }

       /**
        * \brief subscribeOnDataChange : Allows modules to subscribe to a piece of data, in order to get notified when the data changes. Subscribers are called only when the data value has changed.
        * \param dataName Name of the data.
        * \param moduleName Name of the module.
        * \param message message passed to the module when a notification is sent.
        * \param callback name of function to call when a data is changed (default is dataChanged)
        */
       void subscribeOnDataChange ( std::string dataName, std::string moduleName, std::string message, std::string callback )
       {
         callVoid( "subscribeOnDataChange", dataName, moduleName, message, callback );
       }

       /**
        * \brief subscribeOnDataSetTimePolicy : Allows modules to change time policy of already subscribed data.
        * \param dataName Name of the data.
        * \param moduleName Name of the module.
        * \param nTimePolicy time of new policy in ms. Default is 0: no time policy: called at every change/insert. If timepolicy > 0, we will not notifiy under timepolicy even if data change under timepolicy frequency
        */
       void subscribeOnDataSetTimePolicy ( std::string dataName, std::string moduleName, int nTimePolicy )
       {
         callVoid( "subscribeOnDataSetTimePolicy", dataName, moduleName, nTimePolicy );
       }

       /**
        * \brief unregisterModuleReference : Informs ALMemory that a module doesn't exists anymore.
        * \param name Name of the destructed module.
        */
       void unregisterModuleReference ( std::string name )
       {
         callVoid( "unregisterModuleReference", name );
       }

       /**
        * \brief unsubscribeOnData : Allows modules to unsubscribe from a piece of data, in order to stop getting notified when the data changes.
        * \param dataName Name of the data.
        * \param moduleName Name of the module.
        */
       void unsubscribeOnData ( std::string dataName, std::string moduleName )
       {
         callVoid( "unsubscribeOnData", dataName, moduleName );
       }

       /**
        * \brief unsubscribeOnDataChange : Allows modules to unsubscribe from a piece of data and stop getting notified when the data changes.
        * \param dataName Name of the data.
        * \param moduleName Name of the module.
        */
       void unsubscribeOnDataChange ( std::string dataName, std::string moduleName )
       {
         callVoid( "unsubscribeOnDataChange", dataName, moduleName );
       }

       /**
        * \brief version : Returns the revision of the module.
        * \return version_string : the string containing the version
        */
       std::string version (  )
       {
         return call<std::string>( "version" );
       }

       /**
        * \brief wait : wait end of execution method if method was called with pCall
        * \param ID ID of the method to wait
        * \param timeout timeout of the wait in ms. 0 if no timeout
        * \return timeout : True if wait exit with timeout
        */
       bool wait ( int ID, int timeout )
       {
         return call<bool>( "wait", ID, timeout );
       }

       /**
        * \brief waitMethod : wait end of execution method if method was called with pCall
        * \param name name of the method to wait
        * \param timeout timeout of the wait. 0 if no timeout
        * \return timeout : True if wait exit with timeout
        */
       int waitMethod ( std::string name, int timeout )
       {
         return call<int>( "waitMethod", name, timeout );
       }

    };
};

#endif
