/**
 * This file was generated by ALProxyGenerator
 */

#ifndef ALFRAMEMANAGERPROXYPOSTHANDLER_H_
# define ALFRAMEMANAGERPROXYPOSTHANDLER_H_
# include "alproxy.h"
namespace AL
{
  class ALFrameManagerProxy;

  /**
   * ALFrameManagerProxyPostHandler gives acces to all bound methods of the module, using a thread around each call.
   * Long running tasks can be stopped by calling stop(id) with the id returned by the post. 
   */
  class ALFrameManagerProxyPostHandler
    {
       friend class ALFrameManagerProxy;

       protected:
          AL::ALProxy* fParent;

       private:
          void setParent(AL::ALProxy* pParent) { fParent = pParent;}

       public:

       ALFrameManagerProxyPostHandler() : fParent(NULL)
       {}

       /**
        * \brief cleanBehaviors : Stop playing any behavior in FrameManager, and delete all of them.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int cleanBehaviors (  )
       {
         return fParent->pCall( "cleanBehaviors" );
       }

       /**
        * \brief completeBehavior : It will play a behavior and block until the behavior is finished. Note that it can block forever if the behavior output is never called.
        * \param pId The id of the box.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int completeBehavior ( std::string pId )
       {
         return fParent->pCall( "completeBehavior", pId );
       }

       /**
        * \brief createAndPlayTimeline : Creates and play completely a timeline
        * \param pXmlFile The choregraphe project (in plain text for the moment).
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int createAndPlayTimeline ( std::string pXmlFile )
       {
         return fParent->pCall( "createAndPlayTimeline", pXmlFile );
       }

       /**
        * \brief dataChanged : Called by ALMemory when subscribed data has been modified.
        * \param dataName Name of the modified data
        * \param value value of the data
        * \param message associate message.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int dataChanged ( std::string dataName, ALValue value, std::string message )
       {
         return fParent->pCall( "dataChanged", dataName, value, message );
       }

       /**
        * \brief deleteBehavior : Deletes a behavior (meaning a box). Stop the whole behavior contained in this box first.
        * \param pId The id of the box to delete.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int deleteBehavior ( std::string pId )
       {
         return fParent->pCall( "deleteBehavior", pId );
       }

       /**
        * \brief exit : Exit and unregister module, with no params and no return value.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int exit (  )
       {
         return fParent->pCall( "exit" );
       }

       /**
        * \brief exitBehavior : Exit the reading of a timeline contained in a given box
        * \param pId The id of the box.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int exitBehavior ( std::string pId )
       {
         return fParent->pCall( "exitBehavior", pId );
       }

       /**
        * \brief getBrokerName : return the broker name
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getBrokerName (  )
       {
         return fParent->pCall( "getBrokerName" );
       }

       /**
        * \brief getDefaultProject : Get the default project (running when the robot is turned on).
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getDefaultProject (  )
       {
         return fParent->pCall( "getDefaultProject" );
       }

       /**
        * \brief getMethodHelp : Retrieve a method's description
        * \param methodName the name of the method
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getMethodHelp ( std::string methodName )
       {
         return fParent->pCall( "getMethodHelp", methodName );
       }

       /**
        * \brief getMethodList : Retrieve the module's method list.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getMethodList (  )
       {
         return fParent->pCall( "getMethodList" );
       }

       /**
        * \brief getMotionLength : Returns in seconds, the duration of a given movement stored in a box. Returns 0 if the behavior has no motion layers.
        * \param pId The id of the box.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getMotionLength ( std::string pId )
       {
         return fParent->pCall( "getMotionLength", pId );
       }

       /**
        * \brief gotoAndPlay : Goes to a certain frame and continue playing
        * \param pId The id of the box containing the box.
        * \param pFrame The frame we want the timeline to go to.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int gotoAndPlay ( std::string pId, int pFrame )
       {
         return fParent->pCall( "gotoAndPlay", pId, pFrame );
       }

       /**
        * \brief gotoAndStop : Goes to a certain frame and pause
        * \param pId The id of the box containing the box.
        * \param pFrame The frame we want the timeline to go to.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int gotoAndStop ( std::string pId, int pFrame )
       {
         return fParent->pCall( "gotoAndStop", pId, pFrame );
       }

       /**
        * \brief innerTest : Run an internal test to this module.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int innerTest (  )
       {
         return fParent->pCall( "innerTest" );
       }

       /**
        * \brief isRunning : return true if method is currently running
        * \param ID ID of the method to wait
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int isRunning ( int ID )
       {
         return fParent->pCall( "isRunning", ID );
       }

       /**
        * \brief moduleHelp : Retrieve the module's description
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int moduleHelp (  )
       {
         return fParent->pCall( "moduleHelp" );
       }

       /**
        * \brief newBehavior : Creates a new behavior, from a box found in an xml file. Note that you have to give the xml file contents, so this method is not very user friendly. You have to open the file, and send the string that matches the file contents if you are working from a file. You probably want to use newBehaviorFromFile instead.
        * \param pPath The path to reach the box to instantiate in the project ("" if root).
        * \param pXmlFile The choregraphe project (in plain text for the moment).
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int newBehavior ( std::string pPath, std::string pXmlFile )
       {
         return fParent->pCall( "newBehavior", pPath, pXmlFile );
       }

       /**
        * \brief newBehaviorFromFile : Creates a new behavior, from a box found in an xml file stored in the robot.
        * \param pXmlFilePath Path to Xml file, ex : "/home/youhou/mybehavior.xar".
        * \param pPath The path to reach the box to instantiate in the project ("" if root).
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int newBehaviorFromFile ( std::string pXmlFilePath, std::string pPath )
       {
         return fParent->pCall( "newBehaviorFromFile", pXmlFilePath, pPath );
       }

       /**
        * \brief onPythonError : Transmit Python error to Choregraphe or logger. Should not be called manually.
        * \param Boxname Name of the box raising the error
        * \param Methodname Name of the method
        * \param Error Error string
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int onPythonError ( std::string Boxname, std::string Methodname, std::string Error )
       {
         return fParent->pCall( "onPythonError", Boxname, Methodname, Error );
       }

       /**
        * \brief onPythonPrint : Print Python message in Choregraphe or logger. Should not be called manually.
        * \param message Message to print
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int onPythonPrint ( std::string message )
       {
         return fParent->pCall( "onPythonPrint", message );
       }

       /**
        * \brief onRubyError : Transmit Ruby error to Choregraphe or logger. Should not be called manually.
        * \param Boxname Name of the box raising the error
        * \param Methodname Name of the method
        * \param Error Error string
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int onRubyError ( std::string Boxname, std::string Methodname, std::string Error )
       {
         return fParent->pCall( "onRubyError", Boxname, Methodname, Error );
       }

       /**
        * \brief onRubyPrint : Print Ruby message in Choregraphe or logger. Should not be called manually.
        * \param message Message to print
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int onRubyPrint ( std::string message )
       {
         return fParent->pCall( "onRubyPrint", message );
       }

       /**
        * \brief onUrbiError : Transmit Urbi error to Choregraphe or logger. Should not be called manually.
        * \param Boxname Name of the box raising the error
        * \param Methodname Name of the method
        * \param Location Location of the error
        * \param Error Error string
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int onUrbiError ( std::string Boxname, std::string Methodname, std::string Location, std::string Error )
       {
         return fParent->pCall( "onUrbiError", Boxname, Methodname, Location, Error );
       }

       /**
        * \brief onUrbiPrint : Print Urbi message in Choregraphe or logger. Should not be called manually.
        * \param message Message to print
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int onUrbiPrint ( std::string message )
       {
         return fParent->pCall( "onUrbiPrint", message );
       }

       /**
        * \brief ping : Just a ping, with no params and returning always true
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int ping (  )
       {
         return fParent->pCall( "ping" );
       }

       /**
        * \brief playBehavior : Starts playing a timeline contained in a given box
        * \param pId The id of the box.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int playBehavior ( std::string pId )
       {
         return fParent->pCall( "playBehavior", pId );
       }

       /**
        * \brief playDefaultProject : Play default behavior
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int playDefaultProject (  )
       {
         return fParent->pCall( "playDefaultProject" );
       }

       /**
        * \brief resetDefaultProject : Set the default project to an empty one.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int resetDefaultProject (  )
       {
         return fParent->pCall( "resetDefaultProject" );
       }

       /**
        * \brief setDefaultProject : Set the default project (running when the robot is turned on).
        * \param pProject Choregraphe's project in plain text.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setDefaultProject ( std::string pProject )
       {
         return fParent->pCall( "setDefaultProject", pProject );
       }

       /**
        * \brief stopBehavior : Stops playing a timeline contained in a given box, at the current frame
        * \param pId The id of the box.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int stopBehavior ( std::string pId )
       {
         return fParent->pCall( "stopBehavior", pId );
       }

       /**
        * \brief version : Returns the revision of the module.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int version (  )
       {
         return fParent->pCall( "version" );
       }

       /**
        * \brief wait : wait end of execution method if method was called with pCall
        * \param ID ID of the method to wait
        * \param timeout timeout of the wait in ms. 0 if no timeout
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int wait ( int ID, int timeout )
       {
         return fParent->pCall( "wait", ID, timeout );
       }

       /**
        * \brief waitMethod : wait end of execution method if method was called with pCall
        * \param name name of the method to wait
        * \param timeout timeout of the wait. 0 if no timeout
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int waitMethod ( std::string name, int timeout )
       {
         return fParent->pCall( "waitMethod", name, timeout );
       }

    };
};

#endif
