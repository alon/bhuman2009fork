/**
 * This file was generated by ALProxyGenerator
 */

#ifndef ALSPEECHRECOGNITIONPROXYPOSTHANDLER_H_
# define ALSPEECHRECOGNITIONPROXYPOSTHANDLER_H_
# include "alproxy.h"
namespace AL
{
  class ALSpeechRecognitionProxy;

  /**
   * ALSpeechRecognitionProxyPostHandler gives acces to all bound methods of the module, using a thread around each call.
   * Long running tasks can be stopped by calling stop(id) with the id returned by the post. 
   */
  class ALSpeechRecognitionProxyPostHandler
    {
       friend class ALSpeechRecognitionProxy;

       protected:
          AL::ALProxy* fParent;

       private:
          void setParent(AL::ALProxy* pParent) { fParent = pParent;}

       public:

       ALSpeechRecognitionProxyPostHandler() : fParent(NULL)
       {}

       /**
        * \brief dataChanged : Called by ALMemory when subscribed data has been modified.
        * \param dataName Name of the modified data
        * \param value value of the data
        * \param message associate message.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int dataChanged ( std::string dataName, ALValue value, std::string message )
       {
         return fParent->pCall( "dataChanged", dataName, value, message );
       }

       /**
        * \brief exit : Exit and unregister module, with no params and no return value.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int exit (  )
       {
         return fParent->pCall( "exit" );
       }

       /**
        * \brief getArrayParam : Gets a parameter that is shaped as an array.This method is intended to be used by advanced users
        * \param pParamName Name of the parameter.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getArrayParam ( std::string pParamName )
       {
         return fParent->pCall( "getArrayParam", pParamName );
       }

       /**
        * \brief getAvailableLanguages : Returns the list of the languages installed on the system.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getAvailableLanguages (  )
       {
         return fParent->pCall( "getAvailableLanguages" );
       }

       /**
        * \brief getBrokerName : return the broker name
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getBrokerName (  )
       {
         return fParent->pCall( "getBrokerName" );
       }

       /**
        * \brief getCurrentPeriod : gets the parameters chosen by the Extractor 
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getCurrentPeriod (  )
       {
         return fParent->pCall( "getCurrentPeriod" );
       }

       /**
        * \brief getCurrentPrecision : gets the parameters chosen by the Extractor 
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getCurrentPrecision (  )
       {
         return fParent->pCall( "getCurrentPrecision" );
       }

       /**
        * \brief getLanguage : Returns the current language of the speech recognition system.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getLanguage (  )
       {
         return fParent->pCall( "getLanguage" );
       }

       /**
        * \brief getMethodHelp : Retrieve a method's description
        * \param methodName the name of the method
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getMethodHelp ( std::string methodName )
       {
         return fParent->pCall( "getMethodHelp", methodName );
       }

       /**
        * \brief getMethodList : Retrieve the module's method list.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getMethodList (  )
       {
         return fParent->pCall( "getMethodList" );
       }

       /**
        * \brief getMyPeriod :  gets the parameters given by the module 
        * \param name name of the module which has subscribed
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getMyPeriod ( std::string name )
       {
         return fParent->pCall( "getMyPeriod", name );
       }

       /**
        * \brief getMyPrecision :  gets the parameters given by the module 
        * \param name name of the module which has subscribed
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getMyPrecision ( std::string name )
       {
         return fParent->pCall( "getMyPrecision", name );
       }

       /**
        * \brief getOutputNames : get the list of values updated in ALMemory
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getOutputNames (  )
       {
         return fParent->pCall( "getOutputNames" );
       }

       /**
        * \brief getParam : Gets a parameter of the speech recognition engine (Ear speech recognition).
        * \param pParamName Name of the parameter.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getParam ( std::string pParamName )
       {
         return fParent->pCall( "getParam", pParamName );
       }

       /**
        * \brief getSubscribersInfo :  gets the parameters given by the module 
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getSubscribersInfo (  )
       {
         return fParent->pCall( "getSubscribersInfo" );
       }

       /**
        * \brief ignoreAllAudioIn : pause all sound aquisition (to stop while speeh synthetising or ...)
        * \param bSetOrUnset enable the functionnality when true.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int ignoreAllAudioIn ( bool bSetOrUnset )
       {
         return fParent->pCall( "ignoreAllAudioIn", bSetOrUnset );
       }

       /**
        * \brief innerTest : Run an internal test to this module.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int innerTest (  )
       {
         return fParent->pCall( "innerTest" );
       }

       /**
        * \brief isRunning : return true if method is currently running
        * \param ID ID of the method to wait
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int isRunning ( int ID )
       {
         return fParent->pCall( "isRunning", ID );
       }

       /**
        * \brief moduleHelp : Retrieve the module's description
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int moduleHelp (  )
       {
         return fParent->pCall( "moduleHelp" );
       }

       /**
        * \brief ping : Just a ping, with no params and returning always true
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int ping (  )
       {
         return fParent->pCall( "ping" );
       }

       /**
        * \brief setArrayParam : Sets a parameter that is shaped as an array. This method is intended to be used by advanced users
        * \param pParamName Name of the parameter.
        * \param pParamArrayValue Value array.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setArrayParam ( std::string pParamName, ALValue pParamArrayValue )
       {
         return fParent->pCall( "setArrayParam", pParamName, pParamArrayValue );
       }

       /**
        * \brief setDebugMode : enable/disable the printing of some debug information
        * \param bSetOrUnset enable the functionnality when true.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setDebugMode ( bool bSetOrUnset )
       {
         return fParent->pCall( "setDebugMode", bSetOrUnset );
       }

       /**
        * \brief setLanguage : Sets the language of the speech recognition.  The list of the available languages can be get with the getAvailableLanguages method.
        * \param pLanguage Language string. 2 language(s) currently available(s) on the system : English French 
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setLanguage ( std::string pLanguage )
       {
         return fParent->pCall( "setLanguage", pLanguage );
       }

       /**
        * \brief setOutputToFile : enable/disable output of all audioin to file. (direct call AudioInManager::setOutputToFile)
        * \param bSetOrUnset enable the functionnality when true.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setOutputToFile ( bool bSetOrUnset )
       {
         return fParent->pCall( "setOutputToFile", bSetOrUnset );
       }

       /**
        * \brief setParam : Sets a parameter of the speech recognition engine.		The parameters that can be set and the corresponding values are :
	       # EarUseSpeechDetector - Values : 0 (No), 1 (Regular), or 2 (Cepstral) - tells to the recognition system to not recognize frames that seem to be silence	       # EarNoiseReduction - Values : 0 (no) or 1 (yes) - Applies noise reduction to the signal. It's often a good idea to use it, but be warned, it sometimes causes problems to Speech Detection when used in conjunction with the Cepstral Speech Detector.	       # EarSpeed - Values : 0 to 3 - 0 is slowest and most accurate. 3 is the fastest but may add some recognition errors, especially if you talk fast because some parts of the audio data is not processed. - suggested value is 2	       # EarUseFilter : Values : 0 (no) or 1 (yes) - Applies a High-Pass filter on the input signal
        * \param pParamName Name of the parameter.
        * \param pParamValue Value of the parameter.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setParam ( std::string pParamName, float pParamValue )
       {
         return fParent->pCall( "setParam", pParamName, pParamValue );
       }

       /**
        * \brief setVisualExpression : Enables the leds feedback showing the nao state.
        * \param bSetOrNot Enable or disable it.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setVisualExpression ( bool bSetOrNot )
       {
         return fParent->pCall( "setVisualExpression", bSetOrNot );
       }

       /**
        * \brief setWordListAsVocabulary : Sets an array of strings as vocabulary.
        * \param pVocabulary List of words to recognize
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setWordListAsVocabulary ( std::vector<std::string>  pVocabulary )
       {
         return fParent->pCall( "setWordListAsVocabulary", pVocabulary );
       }

       /**
        * \brief startDetection : Start the peak detection.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int startDetection (  )
       {
         return fParent->pCall( "startDetection" );
       }

       /**
        * \brief stopDetection : Stop the peak detection.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int stopDetection (  )
       {
         return fParent->pCall( "stopDetection" );
       }

       /**
        * \brief subscribe :  subscribes to the extractor 
        * \param name name of the module which subscribes
        * \param period refresh period (in millisecond)
        * \param precision precision of the extractor
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int subscribe ( std::string name, int period, float precision )
       {
         return fParent->pCall( "subscribe", name, period, precision );
       }

       /**
        * \brief unsubscribe :  unsubscribes to the extractor 
        * \param name name of the module which has subscribed
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int unsubscribe ( std::string name )
       {
         return fParent->pCall( "unsubscribe", name );
       }

       /**
        * \brief updatePeriod :  updates the parameters 
        * \param name name of the module which has subscribed
        * \param period refresh period (in millisecond)
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int updatePeriod ( std::string name, int period )
       {
         return fParent->pCall( "updatePeriod", name, period );
       }

       /**
        * \brief updatePrecision :  updates the parameters 
        * \param name name of the module which has subscribed
        * \param precision precision of the extractor
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int updatePrecision ( std::string name, float precision )
       {
         return fParent->pCall( "updatePrecision", name, precision );
       }

       /**
        * \brief version : Returns the revision of the module.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int version (  )
       {
         return fParent->pCall( "version" );
       }

       /**
        * \brief wait : wait end of execution method if method was called with pCall
        * \param ID ID of the method to wait
        * \param timeout timeout of the wait in ms. 0 if no timeout
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int wait ( int ID, int timeout )
       {
         return fParent->pCall( "wait", ID, timeout );
       }

       /**
        * \brief waitMethod : wait end of execution method if method was called with pCall
        * \param name name of the method to wait
        * \param timeout timeout of the wait. 0 if no timeout
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int waitMethod ( std::string name, int timeout )
       {
         return fParent->pCall( "waitMethod", name, timeout );
       }

    };
};

#endif
