/**
 * This file was generated by ALProxyGenerator
 */

#ifndef ALVISIONTOOLBOXPROXYPOSTHANDLER_H_
# define ALVISIONTOOLBOXPROXYPOSTHANDLER_H_
# include "alproxy.h"
namespace AL
{
  class ALVisionToolboxProxy;

  /**
   * ALVisionToolboxProxyPostHandler gives acces to all bound methods of the module, using a thread around each call.
   * Long running tasks can be stopped by calling stop(id) with the id returned by the post. 
   */
  class ALVisionToolboxProxyPostHandler
    {
       friend class ALVisionToolboxProxy;

       protected:
          AL::ALProxy* fParent;

       private:
          void setParent(AL::ALProxy* pParent) { fParent = pParent;}

       public:

       ALVisionToolboxProxyPostHandler() : fParent(NULL)
       {}

       /**
        * \brief dataChanged : Called by ALMemory when subscribed data has been modified.
        * \param dataName Name of the modified data
        * \param value value of the data
        * \param message associate message.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int dataChanged ( std::string dataName, ALValue value, std::string message )
       {
         return fParent->pCall( "dataChanged", dataName, value, message );
       }

       /**
        * \brief exit : Exit and unregister module, with no params and no return value.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int exit (  )
       {
         return fParent->pCall( "exit" );
       }

       /**
        * \brief getBrokerName : return the broker name
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getBrokerName (  )
       {
         return fParent->pCall( "getBrokerName" );
       }

       /**
        * \brief getMethodHelp : Retrieve a method's description
        * \param methodName the name of the method
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getMethodHelp ( std::string methodName )
       {
         return fParent->pCall( "getMethodHelp", methodName );
       }

       /**
        * \brief getMethodList : Retrieve the module's method list.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getMethodList (  )
       {
         return fParent->pCall( "getMethodList" );
       }

       /**
        * \brief halfPress : Prepare camera for shooting (like the auto-focus on standard and digital cameras)
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int halfPress (  )
       {
         return fParent->pCall( "halfPress" );
       }

       /**
        * \brief innerTest : Run an internal test to this module.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int innerTest (  )
       {
         return fParent->pCall( "innerTest" );
       }

       /**
        * \brief isItDark : Tell if this is dark around.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int isItDark (  )
       {
         return fParent->pCall( "isItDark" );
       }

       /**
        * \brief isRunning : return true if method is currently running
        * \param ID ID of the method to wait
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int isRunning ( int ID )
       {
         return fParent->pCall( "isRunning", ID );
       }

       /**
        * \brief logTPRInstanceInfo : Print in the logger the info for an instance of takePictureRegurarly()
        * \param pInstanceNumber number of the instance we want to  get info on
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int logTPRInstanceInfo ( int pInstanceNumber )
       {
         return fParent->pCall( "logTPRInstanceInfo", pInstanceNumber );
       }

       /**
        * \brief moduleHelp : Retrieve the module's description
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int moduleHelp (  )
       {
         return fParent->pCall( "moduleHelp" );
       }

       /**
        * \brief ping : Just a ping, with no params and returning always true
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int ping (  )
       {
         return fParent->pCall( "ping" );
       }

       /**
        * \brief setWhiteBalance : Set white balance by using Nao's white hands as reference.
        * \param pCamera Camera we want to set white balance to : [0] top - [1] bottom - [2] both
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int setWhiteBalance ( int pCamera )
       {
         return fParent->pCall( "setWhiteBalance", pCamera );
       }

       /**
        * \brief stopTPR : Stop an instance of takePictureRegularly()
        * \param pPathAndNameRoot path and name root of the file we want to stop recording
        * \param pImageRecordFormat formats of the file we want to stop recording
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int stopTPR ( std::string pPathAndNameRoot, std::string pImageRecordFormat )
       {
         return fParent->pCall( "stopTPR", pPathAndNameRoot, pImageRecordFormat );
       }

       /**
        * \brief takePicture : Shoot 3 successives pictures and place them in the ftp folder (if halfPress is not done before, will take longer between clic and shoot)
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int takePicture (  )
       {
         return fParent->pCall( "takePicture" );
       }

       /**
        * \brief takePictureRegularly : Shoot regularly a picture to follow Nao's evolution in his environment
        * \param pSecondsBetweenTwoShots how many seconds between two pictures?
        * \param pPathAndNameRoot path and the root of the name for the picture
        * \param pOverwriteImage do we need to overwrite the picture, or do we add a timestamp to the name?
        * \param pImageRecordFormat such as jpeg, bmp, png, etc.
        * \param pResolution resolution for the image (e.g. kQQVGA, kQVGA)
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int takePictureRegularly ( float pSecondsBetweenTwoShots, std::string pPathAndNameRoot, bool pOverwriteImage, std::string pImageRecordFormat, int pResolution )
       {
         return fParent->pCall( "takePictureRegularly", pSecondsBetweenTwoShots, pPathAndNameRoot, pOverwriteImage, pImageRecordFormat, pResolution );
       }

       /**
        * \brief version : Returns the revision of the module.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int version (  )
       {
         return fParent->pCall( "version" );
       }

       /**
        * \brief wait : wait end of execution method if method was called with pCall
        * \param ID ID of the method to wait
        * \param timeout timeout of the wait in ms. 0 if no timeout
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int wait ( int ID, int timeout )
       {
         return fParent->pCall( "wait", ID, timeout );
       }

       /**
        * \brief waitMethod : wait end of execution method if method was called with pCall
        * \param name name of the method to wait
        * \param timeout timeout of the wait. 0 if no timeout
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int waitMethod ( std::string name, int timeout )
       {
         return fParent->pCall( "waitMethod", name, timeout );
       }

    };
};

#endif
