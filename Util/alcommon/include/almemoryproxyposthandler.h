/**
 * This file was generated by ALProxyGenerator
 */

#ifndef ALMEMORYPROXYPOSTHANDLER_H_
# define ALMEMORYPROXYPOSTHANDLER_H_
# include "alproxy.h"
namespace AL
{
  class ALMemoryProxy;

  /**
   * ALMemoryProxyPostHandler gives acces to all bound methods of the module, using a thread around each call.
   * Long running tasks can be stopped by calling stop(id) with the id returned by the post. 
   */
  class ALMemoryProxyPostHandler
    {
       friend class ALMemoryProxy;

       protected:
          AL::ALProxy* fParent;

       private:
          void setParent(AL::ALProxy* pParent) { fParent = pParent;}

       public:

       ALMemoryProxyPostHandler() : fParent(NULL)
       {}

       /**
        * \brief dataChanged : Called by ALMemory when subscribed data has been modified.
        * \param dataName Name of the modified data
        * \param value value of the data
        * \param message associate message.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int dataChanged ( std::string dataName, ALValue value, std::string message )
       {
         return fParent->pCall( "dataChanged", dataName, value, message );
       }

       /**
        * \brief exit : Exit and unregister module, with no params and no return value.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int exit (  )
       {
         return fParent->pCall( "exit" );
       }

       /**
        * \brief getBrokerName : return the broker name
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getBrokerName (  )
       {
         return fParent->pCall( "getBrokerName" );
       }

       /**
        * \brief getData : Allows programs and modules to get data stored in ALMemory.
        * \param Name Name of the data.
        * \param duration All the data stored for "duration" seconds will be returned. If 0 returns the lastest value. If -1 returns all stored values.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getData ( std::string Name, int duration )
       {
         return fParent->pCall( "getData", Name, duration );
       }

       /**
        * \brief getDataListName : Allows programs to get an array containing all the data's name.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getDataListName (  )
       {
         return fParent->pCall( "getDataListName" );
       }

       /**
        * \brief getDataOnChange : Allows programs and modules to retrieve data stored in ALMemory, but waits until the data has changed.
        * \param Name Name of the data.
        * \param duration All the data stored for "duration" seconds will be returned. If 0 returns the lastest value. If -1 returns all stored values.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getDataOnChange ( std::string Name, int duration )
       {
         return fParent->pCall( "getDataOnChange", Name, duration );
       }

       /**
        * \brief getListData : Allows programs and modules to retrieve multiple datas stored in ALMemory at the same time.
        * \param Name an array containing the datas' name and their durations.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getListData ( ALValue Name )
       {
         return fParent->pCall( "getListData", Name );
       }

       /**
        * \brief getMethodHelp : Retrieve a method's description
        * \param methodName the name of the method
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getMethodHelp ( std::string methodName )
       {
         return fParent->pCall( "getMethodHelp", methodName );
       }

       /**
        * \brief getMethodList : Retrieve the module's method list.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getMethodList (  )
       {
         return fParent->pCall( "getMethodList" );
       }

       /**
        * \brief getValuesPool : Allows optimised internal access to ALMemory. Please do not use.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int getValuesPool (  )
       {
         return fParent->pCall( "getValuesPool" );
       }

       /**
        * \brief innerTest : Run an internal test to this module.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int innerTest (  )
       {
         return fParent->pCall( "innerTest" );
       }

       /**
        * \brief insertData : Allows any program to insert data into ALMemory.
        * \param Name Name of the data to be inserted.
        * \param Value Value of the data. could be int, double, string, or an array of any of these types.
        * \param lifespan number of data stocked in data historic. When inserting a data, the oldest is erased and leaves its place for the newest
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int insertData ( std::string Name, ALValue Value, int lifespan )
       {
         return fParent->pCall( "insertData", Name, Value, lifespan );
       }

       /**
        * \brief insertListData : Allows any program to insert a list of data into ALMemory.
        * \param listOfInsertData list of [Name, Value, lifespan, waitforAnswer, group] for each data to be inserted.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int insertListData ( ALValue listOfInsertData )
       {
         return fParent->pCall( "insertListData", listOfInsertData );
       }

       /**
        * \brief isRunning : return true if method is currently running
        * \param ID ID of the method to wait
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int isRunning ( int ID )
       {
         return fParent->pCall( "isRunning", ID );
       }

       /**
        * \brief moduleHelp : Retrieve the module's description
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int moduleHelp (  )
       {
         return fParent->pCall( "moduleHelp" );
       }

       /**
        * \brief ping : Just a ping, with no params and returning always true
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int ping (  )
       {
         return fParent->pCall( "ping" );
       }

       /**
        * \brief removeData : Allows programs and modules to retrieve data stored in ALMemory.
        * \param Name Name of the data to be remove.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int removeData ( std::string Name )
       {
         return fParent->pCall( "removeData", Name );
       }

       /**
        * \brief subscribeOnData : Allows modules to subscribe to a piece of data, in order to get notified when the data changes. Subscribers are called whenever the data has been set, even if the new value is the same as the previous one.
        * \param dataName Name of the data.
        * \param moduleName Name of the module.
        * \param message message passed to the module when a notification is sent.
        * \param callback name of function to call when a data is changed (default is dataChanged)
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int subscribeOnData ( std::string dataName, std::string moduleName, std::string message, std::string callback )
       {
         return fParent->pCall( "subscribeOnData", dataName, moduleName, message, callback );
       }

       /**
        * \brief subscribeOnDataChange : Allows modules to subscribe to a piece of data, in order to get notified when the data changes. Subscribers are called only when the data value has changed.
        * \param dataName Name of the data.
        * \param moduleName Name of the module.
        * \param message message passed to the module when a notification is sent.
        * \param callback name of function to call when a data is changed (default is dataChanged)
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int subscribeOnDataChange ( std::string dataName, std::string moduleName, std::string message, std::string callback )
       {
         return fParent->pCall( "subscribeOnDataChange", dataName, moduleName, message, callback );
       }

       /**
        * \brief subscribeOnDataSetTimePolicy : Allows modules to change time policy of already subscribed data.
        * \param dataName Name of the data.
        * \param moduleName Name of the module.
        * \param nTimePolicy time of new policy in ms. Default is 0: no time policy: called at every change/insert. If timepolicy > 0, we will not notifiy under timepolicy even if data change under timepolicy frequency
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int subscribeOnDataSetTimePolicy ( std::string dataName, std::string moduleName, int nTimePolicy )
       {
         return fParent->pCall( "subscribeOnDataSetTimePolicy", dataName, moduleName, nTimePolicy );
       }

       /**
        * \brief unregisterModuleReference : Informs ALMemory that a module doesn't exists anymore.
        * \param name Name of the destructed module.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int unregisterModuleReference ( std::string name )
       {
         return fParent->pCall( "unregisterModuleReference", name );
       }

       /**
        * \brief unsubscribeOnData : Allows modules to unsubscribe from a piece of data, in order to stop getting notified when the data changes.
        * \param dataName Name of the data.
        * \param moduleName Name of the module.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int unsubscribeOnData ( std::string dataName, std::string moduleName )
       {
         return fParent->pCall( "unsubscribeOnData", dataName, moduleName );
       }

       /**
        * \brief unsubscribeOnDataChange : Allows modules to unsubscribe from a piece of data and stop getting notified when the data changes.
        * \param dataName Name of the data.
        * \param moduleName Name of the module.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int unsubscribeOnDataChange ( std::string dataName, std::string moduleName )
       {
         return fParent->pCall( "unsubscribeOnDataChange", dataName, moduleName );
       }

       /**
        * \brief version : Returns the revision of the module.
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int version (  )
       {
         return fParent->pCall( "version" );
       }

       /**
        * \brief wait : wait end of execution method if method was called with pCall
        * \param ID ID of the method to wait
        * \param timeout timeout of the wait in ms. 0 if no timeout
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int wait ( int ID, int timeout )
       {
         return fParent->pCall( "wait", ID, timeout );
       }

       /**
        * \brief waitMethod : wait end of execution method if method was called with pCall
        * \param name name of the method to wait
        * \param timeout timeout of the wait. 0 if no timeout
        * \return brokerTaskID : The ID of the task assigned to it by the broker.
        */
       int waitMethod ( std::string name, int timeout )
       {
         return fParent->pCall( "waitMethod", name, timeout );
       }

    };
};

#endif
