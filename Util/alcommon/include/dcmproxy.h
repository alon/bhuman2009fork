/**
 * This file was generated by ALProxyGenerator
 */

#ifndef DCMPROXY_H_
# define DCMPROXY_H_
# include "alproxy.h"
# include "dcmproxyposthandler.h"

namespace AL
{
  /**
   * DCMProxy gives acces to all bound methods of the module.
   */
  class DCMProxy : public ALProxy
    {
       public:

       /**
        * Local Constructor
        */
       DCMProxy(ALPtr<ALBroker> pBroker) : ALProxy(pBroker, "DCM")
       { post.setParent( (ALProxy*)this );}

       /**
        * Remote Constructor
        */
       DCMProxy(std::string pIP, int pPort) : ALProxy("DCM", pIP, pPort)
       { post.setParent( (ALProxy*)this );}

       /**
        * \brief: Implements thread wrappers around methods
       */
       DCMProxyPostHandler post;

       /**
        * \brief calibration : Calibration of a joint
        * \param pKeyName string : Joint name
        */
       void calibration ( ALValue pKeyName )
       {
         callVoid( "calibration", pKeyName );
       }

       /**
        * \brief createAlias : Create or change an alias (list of actuators)
        * \param pParams Alias name and description
        * \return return : Same as pParams, but with the name removed if the actuator is not found
        */
       ALValue createAlias ( ALValue pParams )
       {
         return call<ALValue>( "createAlias", pParams );
       }

       /**
        * \brief dataChanged : Called by ALMemory when subscribed data has been modified.
        * \param dataName Name of the modified data
        * \param value value of the data
        * \param message associate message.
        */
       void dataChanged ( std::string dataName, ALValue value, std::string message )
       {
         callVoid( "dataChanged", dataName, value, message );
       }

       /**
        * \brief exit : Exit and unregister module, with no params and no return value.
        */
       void exit (  )
       {
         callVoid( "exit" );
       }

       /**
        * \brief getBrokerName : return the broker name
        * \return broker name : string that contain broker name
        */
       std::string getBrokerName (  )
       {
         return call<std::string>( "getBrokerName" );
       }

       /**
        * \brief getMethodHelp : Retrieve a method's description
        * \param methodName the name of the method
        * \return getMethodHelp : a structure containing the method description
        */
       ALValue getMethodHelp ( std::string methodName )
       {
         return call<ALValue>( "getMethodHelp", methodName );
       }

       /**
        * \brief getMethodList : Retrieve the module's method list.
        * \return methodList : an array containing methods name.
        */
       std::vector<std::string>  getMethodList (  )
       {
         return call<std::vector<std::string> >( "getMethodList" );
       }

       /**
        * \brief getPrefix : Return the STM base name
        * \return return : the STM base name for all device/sensors (1st string in the array) and all devices (2nd string in the array)
        */
       ALValue getPrefix (  )
       {
         return call<ALValue>( "getPrefix" );
       }

       /**
        * \brief getTime : Return the DCM time
        * \param pTime optional time in ms (signed) to add/remove
        * \return time : An integer (could be signed) with the DCM time
        */
       int getTime ( int pTime )
       {
         return call<int>( "getTime", pTime );
       }

       /**
        * \brief innerTest : Run an internal test to this module.
        * \return Test_return : true if internal tests are ok
        */
       bool innerTest (  )
       {
         return call<bool>( "innerTest" );
       }

       /**
        * \brief isRunning : return true if method is currently running
        * \param ID ID of the method to wait
        * \return isRunning : True method is currently running
        */
       bool isRunning ( int ID )
       {
         return call<bool>( "isRunning", ID );
       }

       /**
        * \brief moduleHelp : Retrieve the module's description
        * \return moduleHelp : a structure describing the module
        */
       ALValue moduleHelp (  )
       {
         return call<ALValue>( "moduleHelp" );
       }

       /**
        * \brief ping : Just a ping, with no params and returning always true
        * \return alwaysTrue : returns always true
        */
       bool ping (  )
       {
         return call<bool>( "ping" );
       }

       /**
        * \brief preferences : Save updated value from DCM in XML pref file
        * \param pAction string : 'Save' 'Load' 'Add'
        * \param pWhere string : 'Chest' 'Head' 'Main' 'All' 
        * \param pKeyName The name of the key if action = 'Add'.
        * \param pKeyValue The ALVAlue of the key to add
        * \return return : Nothing
        */
       int preferences ( std::string pAction, std::string pWhere, std::string pKeyName, ALValue pKeyValue )
       {
         return call<int>( "preferences", pAction, pWhere, pKeyName, pKeyValue );
       }

       /**
        * \brief set : Call this function to send a timed-command list to an actuator
        * \param pCommands ALValue with all data
        */
       void set ( ALValue pCommands )
       {
         callVoid( "set", pCommands );
       }

       /**
        * \brief setAlias : Call this function to send timed-command list to an alias (list of actuators)
        * \param pCommands ALValue with all data
        */
       void setAlias ( ALValue pCommands )
       {
         callVoid( "setAlias", pCommands );
       }

       /**
        * \brief special : Special DCM commands
        * \param pName one string and could be Reset, Version, Chain, Diagnostic, Config
        */
       void special ( std::string pName )
       {
         callVoid( "special", pName );
       }

       /**
        * \brief version : Returns the revision of the module.
        * \return version_string : the string containing the version
        */
       std::string version (  )
       {
         return call<std::string>( "version" );
       }

       /**
        * \brief wait : wait end of execution method if method was called with pCall
        * \param ID ID of the method to wait
        * \param timeout timeout of the wait in ms. 0 if no timeout
        * \return timeout : True if wait exit with timeout
        */
       bool wait ( int ID, int timeout )
       {
         return call<bool>( "wait", ID, timeout );
       }

       /**
        * \brief waitMethod : wait end of execution method if method was called with pCall
        * \param name name of the method to wait
        * \param timeout timeout of the wait. 0 if no timeout
        * \return timeout : True if wait exit with timeout
        */
       int waitMethod ( std::string name, int timeout )
       {
         return call<int>( "waitMethod", name, timeout );
       }

    };
};

#endif
