/**
 * This file was generated by ALProxyGenerator
 */

#ifndef ALMOTIONPROXY_H_
# define ALMOTIONPROXY_H_
# include "alproxy.h"
# include "almotionproxyposthandler.h"

#define TO_RAD 0.01745329f
namespace AL
{
  /**
   * ALMotionProxy gives acces to all bound methods of the module.
   */
  class ALMotionProxy : public ALProxy
    {
       public:

       /**
        * Local Constructor
        */
       ALMotionProxy(ALPtr<ALBroker> pBroker) : ALProxy(pBroker, "ALMotion")
       { post.setParent( (ALProxy*)this );}

       /**
        * Remote Constructor
        */
       ALMotionProxy(std::string pIP, int pPort) : ALProxy("ALMotion", pIP, pPort)
       { post.setParent( (ALProxy*)this );}

       /**
        * \brief: Implements thread wrappers around methods
       */
       ALMotionProxyPostHandler post;

       /**
        * \brief addTurn : Adds a turn in place walk pattern that could result in several footsteps.
        * \param pAngle Angle to turn in radians e.g. 0.5.
        * \param pNumSamplesPerStep Number of 20ms cycles per step. e.g. 60.
        */
       void addTurn ( float pAngle, int pNumSamplesPerStep )
       {
         callVoid( "addTurn", pAngle, pNumSamplesPerStep );
       }

       /**
        * \brief addWalkArc : Adds a circular walk pattern that could result in several footsteps
        * \param pAngle Angle of the arc of the circle to turn in radians e.g. 0.5.
        * \param pRadius Radius of the circle in meters e.g. 1.5.
        * \param pNumSamplesPerStep Number of 20ms cycles per step. e.g. 60.
        */
       void addWalkArc ( float pAngle, float pRadius, int pNumSamplesPerStep )
       {
         callVoid( "addWalkArc", pAngle, pRadius, pNumSamplesPerStep );
       }

       /**
        * \brief addWalkSideways : Adds a sideways walk pattern that could result in several footsteps.
        * \param pDistance Sideways distance in meters e.g. -0.1.
        * \param pNumSamplesPerStep Number of 20ms cycles per step. e.g. 60.
        */
       void addWalkSideways ( float pDistance, int pNumSamplesPerStep )
       {
         callVoid( "addWalkSideways", pDistance, pNumSamplesPerStep );
       }

       /**
        * \brief addWalkStraight : Adds a straight walk pattern that could result in several forwards or backwards footsteps
        * \param pDistance Distance in meters e.g. 0.1.
        * \param pNumSamplesPerStep Number of 20ms cycles per step. e.g. 60.
        */
       void addWalkStraight ( float pDistance, int pNumSamplesPerStep )
       {
         callVoid( "addWalkStraight", pDistance, pNumSamplesPerStep );
       }

       /**
        * \brief areResourcesAvailable : Returns true if the resources are available.
        * \param pResourceNames A vector of resource names such as joints
        * \return value : True if the resources are available
        */
       bool areResourcesAvailable ( std::vector<std::string>  pResourceNames )
       {
         return call<bool>( "areResourcesAvailable", pResourceNames );
       }

       /**
        * \brief changeAngle : Changes the angle of a joint relative to the current angle.
        * \param pJointName Name of the joint. Could be: "HeadYaw", "HeadPitch", "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw", "LHand", "LHipYawPitch", "LHipRoll", "LHipPitch", "LKneePitch", "LAnklePitch", "LAnkleRoll", "RHipYawPitch", "RHipRoll", "RHipPitch", "RKneePitch", "RAnklePitch", "RAnkleRoll", "RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw", "RHand"
        * \param pAngleChange Angle change in radians.
        */
       void changeAngle ( std::string pJointName, float pAngleChange )
       {
         callVoid( "changeAngle", pJointName, pAngleChange );
       }

       /**
        * \brief changeBodyAngles : Changes the angles relative to the current angles of all the joints in the body.
        * \param pAngleChanges Vector of angle changes.
        */
       void changeBodyAngles ( std::vector<float>  pAngleChanges )
       {
         callVoid( "changeBodyAngles", pAngleChanges );
       }

       /**
        * \brief changeChainAngles : Changes the angles of the joints relative to the current angle in the specified chain. The number of angles required depends on the length of the chain.
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \param pAngleChanges Vector of angles changes in radians.
        */
       void changeChainAngles ( std::string pChainName, std::vector<float>  pAngleChanges )
       {
         callVoid( "changeChainAngles", pChainName, pAngleChanges );
       }

       /**
        * \brief changeCom : Changes the position of the Center of Mass relative to the support Leg. Units are meters.
        * \param pXd x component of the COM change.
        * \param pYd y component of the COM change.
        * \param pZd z component of the COM change.
        */
       void changeCom ( float pXd, float pYd, float pZd )
       {
         callVoid( "changeCom", pXd, pYd, pZd );
       }

       /**
        * \brief changePosition : Creates a move of an end effector in cartesian space.
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \param pSpace Task space.
        * \param pPositionChange 6D position change array (xd,yd,zd,wxd,wyd,wzd) in meters and radians
        * \param pAxisMask Axis mask. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both 
        */
       void changePosition ( std::string pChainName, int pSpace, std::vector<float>  pPositionChange, int pAxisMask )
       {
         callVoid( "changePosition", pChainName, pSpace, pPositionChange, pAxisMask );
       }

       /**
        * \brief clearFootsteps : Removes all pending footsteps from the queue.
        */
       void clearFootsteps (  )
       {
         callVoid( "clearFootsteps" );
       }

       /**
        * \brief closeHand : Closes the hand, then cuts motor current to conserve energy.
        * \param pHandName The name of the hand. Could be: "RHand" or "LHand"
        */
       void closeHand ( std::string pHandName )
       {
         callVoid( "closeHand", pHandName );
       }

       /**
        * \brief dataChanged : Called by ALMemory when subscribed data has been modified.
        * \param dataName Name of the modified data
        * \param value value of the data
        * \param message associate message.
        */
       void dataChanged ( std::string dataName, ALValue value, std::string message )
       {
         callVoid( "dataChanged", dataName, value, message );
       }

       /**
        * \brief doMove : Interpolates a sequence of timed angles for several motors.
        * \param pJointNames The joint names corresponding to the outer array of angles and times
        * \param pAngles An ALValue matrix of angles in radians corresponding to the times for each motor.
        * \param pTimes An ALValue matrix of times in seconds corresponding to each motor
        * \param pInterpolationType The type of interpolation { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        */
       void doMove ( ALValue pJointNames, ALValue pAngles, ALValue pTimes, int pInterpolationType )
       {
         callVoid( "doMove", pJointNames, pAngles, pTimes, pInterpolationType );
       }

       /**
        * \brief exit : Exit and unregister module, with no params and no return value.
        */
       void exit (  )
       {
         callVoid( "exit" );
       }

       /**
        * \brief getAngle : Gets the sensed angle of the joint
        * \param pJointName Name of the joint. Could be: "HeadYaw", "HeadPitch", "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw", "LHand", "LHipYawPitch", "LHipRoll", "LHipPitch", "LKneePitch", "LAnklePitch", "LAnkleRoll", "RHipYawPitch", "RHipRoll", "RHipPitch", "RKneePitch", "RAnklePitch", "RAnkleRoll", "RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw", "RHand"
        * \return value : Sensed Angle of the joint in radians.
        */
       float getAngle ( std::string pJointName )
       {
         return call<float>( "getAngle", pJointName );
       }

       /**
        * \brief getAngleError : Gets the error between the command and sensed angle of the joint
        * \param pJointName Name of the joint. Could be: "HeadYaw", "HeadPitch", "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw", "LHand", "LHipYawPitch", "LHipRoll", "LHipPitch", "LKneePitch", "LAnklePitch", "LAnkleRoll", "RHipYawPitch", "RHipRoll", "RHipPitch", "RKneePitch", "RAnklePitch", "RAnkleRoll", "RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw", "RHand"
        * \return value : Angle error of the joint in radians.
        */
       float getAngleError ( std::string pJointName )
       {
         return call<float>( "getAngleError", pJointName );
       }

       /**
        * \brief getBalanceMode : Gets the balance mode which can be used to change the way nao responds to commands while keeping balance.
        * \return value : Balance mode {BALANCE_MODE_OFF = 0, BALANCE_MODE_AUTO = 1, BALANCE_MODE_COM_CONTROL = 2}
        */
       int getBalanceMode (  )
       {
         return call<int>( "getBalanceMode" );
       }

       /**
        * \brief getBodyAngleErrors : Gets the errors between the command and sensed angles of all the joints in the body, moving clockwise starting with the head chain. See getBodyJointNames()
        * \return value : Vector of angles errors, one for each joint.
        */
       std::vector<float>  getBodyAngleErrors (  )
       {
         return call<std::vector<float> >( "getBodyAngleErrors" );
       }

       /**
        * \brief getBodyAngles : Gets the sensed angles of all the joints in the body, moving clockwise starting with the head chain. See getBodyJointNames()
        * \return value : Vector of sensed angles in radians, one for each joint.
        */
       std::vector<float>  getBodyAngles (  )
       {
         return call<std::vector<float> >( "getBodyAngles" );
       }

       /**
        * \brief getBodyCommandAngles : Gets the command angles of all the joints in the body, moving clockwise starting with the head chain. See getBodyJointNames()
        * \return value : Vector of command angles, one for each joint, in the same order as the names returned by getBodyJointNames()
        */
       std::vector<float>  getBodyCommandAngles (  )
       {
         return call<std::vector<float> >( "getBodyCommandAngles" );
       }

       /**
        * \brief getBodyJointNames : Gets the names of all the joints in the body.
        * \return value : Vector of strings, one for each joint in Nao's body, moving clockwise from the head chain.
        */
       std::vector<std::string>  getBodyJointNames (  )
       {
         return call<std::vector<std::string> >( "getBodyJointNames" );
       }

       /**
        * \brief getBodyLimits : Gets the minAngle, maxAngle, and maxChangePerCycle for all the joints in the body, moving clockwise starting with the head chain. See getBodyJointNames()
        * \return value : Array of ALValue arrays containing the minAngle, maxAngle, and maxChangePerCycle for all the joints in the body. 
        */
       ALValue getBodyLimits (  )
       {
         return call<ALValue>( "getBodyLimits" );
       }

       /**
        * \brief getBodyStiffnesses : Gets the stiffnesses of all the joints in the body, moving clockwise starting with the head chain. See getBodyJointNames()
        * \return stiffnesses : A vector containing the stiffnesses
        */
       std::vector<float>  getBodyStiffnesses (  )
       {
         return call<std::vector<float> >( "getBodyStiffnesses" );
       }

       /**
        * \brief getBrokerName : return the broker name
        * \return broker name : string that contain broker name
        */
       std::string getBrokerName (  )
       {
         return call<std::string>( "getBrokerName" );
       }

       /**
        * \brief getChainAngleErrors : Gets the errors between the command and sensed angles of the joints in a chain.
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \return value : Vector of angle errors in radians, one for each joint in the chain.
        */
       std::vector<float>  getChainAngleErrors ( std::string pChainName )
       {
         return call<std::vector<float> >( "getChainAngleErrors", pChainName );
       }

       /**
        * \brief getChainAngles : Gets the sensed angles of the joints in a chain.
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \return value : Vector of sensed angles in radians, one for each joint in the chain.
        */
       std::vector<float>  getChainAngles ( std::string pChainName )
       {
         return call<std::vector<float> >( "getChainAngles", pChainName );
       }

       /**
        * \brief getChainCommandAngles : Gets the angles of the joints in the specified chain. The number of angles returned depends on the length of the chain.
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \return value : Vector of angles in radians, one for each motor in the chain.
        */
       std::vector<float>  getChainCommandAngles ( std::string pChainName )
       {
         return call<std::vector<float> >( "getChainCommandAngles", pChainName );
       }

       /**
        * \brief getChainLimits : Get the minAngle, maxAngle, and maxChangePerCycle for a given chain in the body.
        * \param pChainName Chain name. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \return value : Array of ALValue arrays containing the minAngle, maxAngle and maxChangePerCycle for all the joints of the chain
        */
       ALValue getChainLimits ( std::string pChainName )
       {
         return call<ALValue>( "getChainLimits", pChainName );
       }

       /**
        * \brief getChainStiffnesses : Gets the stiffnesses of all the joints in a chain
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \return stiffnesses : A vector containing the stiffnesses
        */
       std::vector<float>  getChainStiffnesses ( std::string pChainName )
       {
         return call<std::vector<float> >( "getChainStiffnesses", pChainName );
       }

       /**
        * \brief getCom : Gets the position of the Center of Mass relative to the support Leg. Units are meters.
        * \param pSpace Task space.
        * \return value : Vector of positions in meters [x, y, z].
        */
       std::vector<float>  getCom ( int pSpace )
       {
         return call<std::vector<float> >( "getCom", pSpace );
       }

       /**
        * \brief getCommandAngle : Gets the command angle of a joint.
        * \param pJointName Name of the Joint. Could be: "HeadYaw", "HeadPitch", "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw", "LHand", "LHipYawPitch", "LHipRoll", "LHipPitch", "LKneePitch", "LAnklePitch", "LAnkleRoll", "RHipYawPitch", "RHipRoll", "RHipPitch", "RKneePitch", "RAnklePitch", "RAnkleRoll", "RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw", "RHand"
        * \return value : Angle of the joint in radians.
        */
       float getCommandAngle ( std::string pJointName )
       {
         return call<float>( "getCommandAngle", pJointName );
       }

       /**
        * \brief getForwardTransform : Gets the forward Homogenous Transform of a Chain relative to the TASK_SPACE.
        * \param pChainName Chain name. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \param pSpace Task space {SPACE_BODY = 0, SPACE_SUPPORT_LEG = 1 }
        * \return value : Vector of 16 floats corresponding to the values of the matrix, line by line.
        */
       std::vector<float>  getForwardTransform ( std::string pChainName, int pSpace )
       {
         return call<std::vector<float> >( "getForwardTransform", pChainName, pSpace );
       }

       /**
        * \brief getJointLimits : Get the minAngle, maxAngle, and maxChangePerCycle for a given joint in the body.
        * \param pJointName Joint name.
        * \return value : Array of ALValue arrays containing the minAngle, maxAngle and maxChangePerCycle for the given joint.
        */
       std::vector<float>  getJointLimits ( std::string pJointName )
       {
         return call<std::vector<float> >( "getJointLimits", pJointName );
       }

       /**
        * \brief getJointSpeedParams : Gets the user parameters for speed and acceleration control.
        * \param pJointName The name of the joint
        * \return speedParams : A vector of floats containing: UserMaxSpeed,UserMaxAcceleration,UserMaxDeceleration
        */
       std::vector<float>  getJointSpeedParams ( std::string pJointName )
       {
         return call<std::vector<float> >( "getJointSpeedParams", pJointName );
       }

       /**
        * \brief getJointStiffness : Gets stiffness of a joint
        * \param pJointName Name of the Joint. Could be:"HeadYaw", "HeadPitch", "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw", "LHand", "LHipYawPitch", "LHipRoll", "LHipPitch", "LKneePitch", "LAnklePitch", "LAnkleRoll", "RHipYawPitch", "RHipRoll", "RHipPitch", "RKneePitch", "RAnklePitch", "RAnkleRoll", "RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw", "RHand"
        * \return stiffness : Stiffness of the joint
        */
       float getJointStiffness ( std::string pJointName )
       {
         return call<float>( "getJointStiffness", pJointName );
       }

       /**
        * \brief getMethodHelp : Retrieve a method's description
        * \param methodName the name of the method
        * \return getMethodHelp : a structure containing the method description
        */
       ALValue getMethodHelp ( std::string methodName )
       {
         return call<ALValue>( "getMethodHelp", methodName );
       }

       /**
        * \brief getMethodList : Retrieve the module's method list.
        * \return methodList : an array containing methods name.
        */
       std::vector<std::string>  getMethodList (  )
       {
         return call<std::vector<std::string> >( "getMethodList" );
       }

       /**
        * \brief getPosition : Gets the Position of a Chain relative to the TASK_SPACE.
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \param pSpace Task space {SPACE_BODY = 0, SPACE_SUPPORT_LEG = 1 }
        * \return value : Vector containing the Position6D. (x, y, z, wx, wy, wz )
        */
       std::vector<float>  getPosition ( std::string pChainName, int pSpace )
       {
         return call<std::vector<float> >( "getPosition", pChainName, pSpace );
       }

       /**
        * \brief getRemainingFootStepCount : Get number of remaining footsteps in the current Walk task
        * \return remainingFootStepsCount : number of remaining footsteps in the current walk task, or zero if there is no active walk task.
        */
       int getRemainingFootStepCount (  )
       {
         return call<int>( "getRemainingFootStepCount" );
       }

       /**
        * \brief getSensorPosition : Gets the Position of a Sensor relative to a TASK_SPACE.
        * \param pSensorName Name of the sensor {CameraTop, CameraBottom, MicroFront, MicroRear, MicroLeft, MicroRight} 
        * \param pSpace Task space {SPACE_BODY = 0, SPACE_SUPPORT_LEG = 1 }
        * \return value : Vector containing the Position6D. (x, y, z, wx, wy, wz )
        */
       std::vector<float>  getSensorPosition ( std::string pSensorName, int pSpace )
       {
         return call<std::vector<float> >( "getSensorPosition", pSensorName, pSpace );
       }

       /**
        * \brief getSummary : Returns a string representation of the Model's state
        * \return value : A formated string
        */
       std::string getSummary (  )
       {
         return call<std::string>( "getSummary" );
       }

       /**
        * \brief getSupportMode : Gets the support mode.
        * \return value : Balance mode { SUPPORT_MODE_LEFT = 0, SUPPORT_MODE_DOUBLE_LEFT = 1, SUPPORT_MODE_RIGHT = 2, SUPPORT_MODE_DOUBLE_RIGHT = 3}
        */
       int getSupportMode (  )
       {
         return call<int>( "getSupportMode" );
       }

       /**
        * \brief getTaskList : Gets an ALValue structure describing the tasks in the Task List
        * \return value : An ALValue containing an ALValue for each task. The inner ALValue contains: Name, MotionID, BrokerID, Priority, Resources
        */
       ALValue getTaskList (  )
       {
         return call<ALValue>( "getTaskList" );
       }

       /**
        * \brief getVerbosity : Gets the current verbosity level
        * \return value : The verbosity level
        */
       int getVerbosity (  )
       {
         return call<int>( "getVerbosity" );
       }

       /**
        * \brief getWalkArmsConfig : Gets the parameters that will be used for Arms next time a WalkTask is created.
        * \return value : Walk arms configuration: pShoulderMedian, pShoulderAmplitude, pElbowMedian, pElbowAmplitude.
        */
       std::vector<float>  getWalkArmsConfig (  )
       {
         return call<std::vector<float> >( "getWalkArmsConfig" );
       }

       /**
        * \brief getWalkArmsEnable : Gets if Arms Motions are enabled during the Walk Process.
        * \return value : True Arm Motions are controlled by the Walk Task.
        */
       bool getWalkArmsEnable (  )
       {
         return call<bool>( "getWalkArmsEnable" );
       }

       /**
        * \brief getWalkConfig : Gets the parameters that will be used next time a WalkTask is created.
        * \return value : Walk configuration: MaxStepLength, MaxStepHeight, MaxStepSide, MaxStepTurn.
        */
       std::vector<float>  getWalkConfig (  )
       {
         return call<std::vector<float> >( "getWalkConfig" );
       }

       /**
        * \brief getWalkTrapezoidConfig : Gets the parameters that will be used next time a WalkTask is created.
        * \return value : Walk trapezoid configuration: pLRollBacklashCompensator,	pRRollBacklashCompensator.
        */
       std::vector<float>  getWalkTrapezoidConfig (  )
       {
         return call<std::vector<float> >( "getWalkTrapezoidConfig" );
       }

       /**
        * \brief gotoAngle : Interpolates the angle of a joint from the current angles to the target.
        * \param pJointName Name of the Joint. Could be: "HeadYaw", "HeadPitch", "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw", "LHand", "LHipYawPitch", "LHipRoll", "LHipPitch", "LKneePitch", "LAnklePitch", "LAnkleRoll", "RHipYawPitch", "RHipRoll", "RHipPitch", "RKneePitch", "RAnklePitch", "RAnkleRoll", "RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw", "RHand"
        * \param pAngle Target angle of the motor in radians.
        * \param pDuration Duration of interpolation in seconds.
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        */
       void gotoAngle ( std::string pJointName, float pAngle, float pDuration, int pInterpolationType )
       {
         callVoid( "gotoAngle", pJointName, pAngle, pDuration, pInterpolationType );
       }

       /**
        * \brief gotoAngleWithSpeed : Interpolates the angle of a joint from the current angles to the target.
        * \param pJointName Name of the Joint. Could be: "HeadYaw", "HeadPitch", "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw", "LHand", "LHipYawPitch", "LHipRoll", "LHipPitch", "LKneePitch", "LAnklePitch", "LAnkleRoll", "RHipYawPitch", "RHipRoll", "RHipPitch", "RKneePitch", "RAnklePitch", "RAnkleRoll", "RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw", "RHand"
        * \param pAngle Target angle of the motor in radians.
        * \param pSpeedPercent A Percent relative to Max Speed use for this motion {1~100)
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        */
       void gotoAngleWithSpeed ( std::string pJointName, float pAngle, int pSpeedPercent, int pInterpolationType )
       {
         callVoid( "gotoAngleWithSpeed", pJointName, pAngle, pSpeedPercent, pInterpolationType );
       }

       /**
        * \brief gotoAngles : Interpolates a collection of joints from the current angles to the targets using a fixed duration.
        * \param pJointNames Names of the Joints. Could be: "HeadYaw", "HeadPitch", "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw", "LHand", "LHipYawPitch", "LHipRoll", "LHipPitch", "LKneePitch", "LAnklePitch", "LAnkleRoll", "RHipYawPitch", "RHipRoll", "RHipPitch", "RKneePitch", "RAnklePitch", "RAnkleRoll", "RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw", "RHand"
        * \param pTargetAngles Target angles of the motors in radians.
        * \param pDuration The duration of the interpolation in seconds.
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        */
       void gotoAngles ( std::vector<std::string>  pJointNames, std::vector<float>  pTargetAngles, float pDuration, int pInterpolationType )
       {
         callVoid( "gotoAngles", pJointNames, pTargetAngles, pDuration, pInterpolationType );
       }

       /**
        * \brief gotoAnglesWithSpeed : Interpolates a collection of joints from the current angles to the targets using a percentage of max speed.
        * \param pJointNames Names of the Joints. Could be: "HeadYaw", "HeadPitch", "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw", "LHand", "LHipYawPitch", "LHipRoll", "LHipPitch", "LKneePitch", "LAnklePitch", "LAnkleRoll", "RHipYawPitch", "RHipRoll", "RHipPitch", "RKneePitch", "RAnklePitch", "RAnkleRoll", "RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw", "RHand"
        * \param pTargetAngles Target angles of the motors in radians.
        * \param pSpeedPercent A Percent relative to Max Speed use for this motion {1~100)
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        */
       void gotoAnglesWithSpeed ( std::vector<std::string>  pJointNames, std::vector<float>  pTargetAngles, int pSpeedPercent, int pInterpolationType )
       {
         callVoid( "gotoAnglesWithSpeed", pJointNames, pTargetAngles, pSpeedPercent, pInterpolationType );
       }

       /**
        * \brief gotoBodyAngles : Interpolates the angles of the joints in the body from the current position to the target.
        * \param pAngles Target angles in radians of all the motors in the chain.
        * \param pDuration Duration of interpolation in seconds.
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        */
       void gotoBodyAngles ( std::vector<float>  pAngles, float pDuration, int pInterpolationType )
       {
         callVoid( "gotoBodyAngles", pAngles, pDuration, pInterpolationType );
       }

       /**
        * \brief gotoBodyAnglesWithSpeed : Interpolates the angles of the joints in the body from the current position to the target.
        * \param pAngles Target angles in radians of all the motors in the chain.
        * \param pSpeedPercent A Percent relative to Max Speed use for this motion {1~100)
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        */
       void gotoBodyAnglesWithSpeed ( std::vector<float>  pAngles, int pSpeedPercent, int pInterpolationType )
       {
         callVoid( "gotoBodyAnglesWithSpeed", pAngles, pSpeedPercent, pInterpolationType );
       }

       /**
        * \brief gotoBodyStiffness : Function to Set the stiffness of all the motors in the body; {0.0 : No Joint Control (the motor is in break mode) 1.0: Full joint Control (the error between Command and Sensor is as small as possible) }
        * \param pStiffness Stiffness between zero and one
        * \param pDuration Duration of the interpolation in seconds.
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        */
       void gotoBodyStiffness ( float pStiffness, float pDuration, int pInterpolationType )
       {
         callVoid( "gotoBodyStiffness", pStiffness, pDuration, pInterpolationType );
       }

       /**
        * \brief gotoBodyStiffnesses : Interpolates the stiffnesses of all the motors from the cureent stiffnesses to the targets
        * \param pStiffnesses Target stiffnesses. Must be a vector of floats between 0 and 1.
        * \param pDuration Duration of interpolation in seconds.
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        * \return none : none
        */
       int gotoBodyStiffnesses ( std::vector<float>  pStiffnesses, float pDuration, int pInterpolationType )
       {
         return call<int>( "gotoBodyStiffnesses", pStiffnesses, pDuration, pInterpolationType );
       }

       /**
        * \brief gotoChainAngles : Interpolates the angles of the joints in the specified chain from the current angles to the target. The number of angles required depends on the length of the chain.
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \param pAngles Target angles in radians
        * \param pDuration Duration of interpolation in seconds.
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        */
       void gotoChainAngles ( std::string pChainName, std::vector<float>  pAngles, float pDuration, int pInterpolationType )
       {
         callVoid( "gotoChainAngles", pChainName, pAngles, pDuration, pInterpolationType );
       }

       /**
        * \brief gotoChainAnglesWithSpeed : Interpolates the angles of the joints in the specified chain from the current angles to the target. The number of angles required depends on the length of the chain.
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \param pAngles Target angles in radians
        * \param pSpeedPercent A Percent relative to Max Speed use for this motion {1~100)
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        */
       void gotoChainAnglesWithSpeed ( std::string pChainName, std::vector<float>  pAngles, int pSpeedPercent, int pInterpolationType )
       {
         callVoid( "gotoChainAnglesWithSpeed", pChainName, pAngles, pSpeedPercent, pInterpolationType );
       }

       /**
        * \brief gotoChainStiffness : Function to Set the stiffness of all the motors in the chain; {0.0 : No Joint Control (the motor is in break mode) 1.0: Full joint Control (the error between Command and Sensor is as small as possible) }
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \param pStiffness Stiffness between zero and one.
        * \param pDuration Duration of the interpolation in seconds. 
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        */
       void gotoChainStiffness ( std::string pChainName, float pStiffness, float pDuration, int pInterpolationType )
       {
         callVoid( "gotoChainStiffness", pChainName, pStiffness, pDuration, pInterpolationType );
       }

       /**
        * \brief gotoChainStiffnesses : Interpolates the stiffnesses of a chain from the current stiffnesses to the targets.
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \param pStiffnesses Target stiffnesses. Must be a vector of floats between 0 and 1.
        * \param pDuration Duration of interpolation in seconds.
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        * \return none : none
        */
       int gotoChainStiffnesses ( std::string pChainName, std::vector<float>  pStiffnesses, float pDuration, int pInterpolationType )
       {
         return call<int>( "gotoChainStiffnesses", pChainName, pStiffnesses, pDuration, pInterpolationType );
       }

       /**
        * \brief gotoCom : Moves the position of the Center of Mass over time in absolute frame.
        * \param pX x component of the COM target
        * \param pY y component of the COM target
        * \param pZ z component of the COM target
        * \param pDuration Duration of the interpolation in seconds.
        * \param pInterpolationType The type of interpolation { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        */
       void gotoCom ( float pX, float pY, float pZ, float pDuration, int pInterpolationType )
       {
         callVoid( "gotoCom", pX, pY, pZ, pDuration, pInterpolationType );
       }

       /**
        * \brief gotoJointStiffness : Interpolates the stiffness of a joint from the current stiffness to the target.
        * \param pJointName Name of the joint. Could be: "HeadYaw", "HeadPitch", "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw", "LHand", "LHipYawPitch", "LHipRoll", "LHipPitch", "LKneePitch", "LAnklePitch", "LAnkleRoll", "RHipYawPitch", "RHipRoll", "RHipPitch", "RKneePitch", "RAnklePitch", "RAnkleRoll", "RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw", "RHand"
        * \param pStiffness Target stiffness. Must be a float between 0 and 1.
        * \param pDuration Duration of interpolation in seconds.
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        * \return none : none
        */
       int gotoJointStiffness ( std::string pJointName, float pStiffness, float pDuration, int pInterpolationType )
       {
         return call<int>( "gotoJointStiffness", pJointName, pStiffness, pDuration, pInterpolationType );
       }

       /**
        * \brief gotoJointStiffnesses : Interpolates the stiffness of a group of joint from the current stiffness to the target.
        * \param pJointNames A vector containing the names of the joints. Could be: "HeadYaw", "HeadPitch", "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw", "LHand", "LHipYawPitch", "LHipRoll", "LHipPitch", "LKneePitch", "LAnklePitch", "LAnkleRoll", "RHipYawPitch", "RHipRoll", "RHipPitch", "RKneePitch", "RAnklePitch", "RAnkleRoll", "RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw", "RHand"
        * \param pStiffness A vector containing the target stiffnesses. Must be floats between 0 and 1.
        * \param pDuration Duration of interpolation in seconds.
        * \param pInterpolationType Type of interpolation to do. { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        * \return none : none
        */
       int gotoJointStiffnesses ( std::vector<std::string>  pJointNames, std::vector<float>  pStiffness, float pDuration, int pInterpolationType )
       {
         return call<int>( "gotoJointStiffnesses", pJointNames, pStiffness, pDuration, pInterpolationType );
       }

       /**
        * \brief gotoPosition : Moves an end-effector to the given position and orientation over time.
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \param pSpace Task space
        * \param pPosition 6D position array (x,y,z,wx,wy,wz) in meters and radians
        * \param pAxisMask Axis mask. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both 
        * \param pDuration Duration of the interpolation in seconds
        * \param pInterpolationType Type of interpolation { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        */
       void gotoPosition ( std::string pChainName, int pSpace, std::vector<float>  pPosition, int pAxisMask, float pDuration, int pInterpolationType )
       {
         callVoid( "gotoPosition", pChainName, pSpace, pPosition, pAxisMask, pDuration, pInterpolationType );
       }

       /**
        * \brief gotoTorsoOrientation : Function to rotate the torso over time in absolute frame.
        * \param pX x component of the torso orientation in radians.
        * \param pY y component of the torso orientation in radians.
        * \param pDuration Duration of the interpolation in seconds.
        * \param pInterpolationType Type of interpolation { INTERPOLATION_LINEAR = 0, INTERPOLATION_SMOOTH = 1 }
        */
       void gotoTorsoOrientation ( float pX, float pY, float pDuration, int pInterpolationType )
       {
         callVoid( "gotoTorsoOrientation", pX, pY, pDuration, pInterpolationType );
       }

       /**
        * \brief innerTest : Run an internal test to this module.
        * \return Test_return : true if internal tests are ok
        */
       bool innerTest (  )
       {
         return call<bool>( "innerTest" );
       }

       /**
        * \brief isRunning : return true if method is currently running
        * \param ID ID of the method to wait
        * \return isRunning : True method is currently running
        */
       bool isRunning ( int ID )
       {
         return call<bool>( "isRunning", ID );
       }

       /**
        * \brief killAll : Kills all tasks.
        */
       void killAll (  )
       {
         callVoid( "killAll" );
       }

       /**
        * \brief killTask : Kills a task.
        * \param pTaskID TaskID of the task you want to kill. The TaskID is returned from any action which was added with a method prefixed with add
        * \return value : False if the task could not be found
        */
       bool killTask ( int pTaskID )
       {
         return call<bool>( "killTask", pTaskID );
       }

       /**
        * \brief killTasksUsingResources : Kills all tasks that use any of the resources given.
        * \param pResourceNames A vector of resource names such as joints
        */
       void killTasksUsingResources ( std::vector<std::string>  pResourceNames )
       {
         callVoid( "killTasksUsingResources", pResourceNames );
       }

       /**
        * \brief moduleHelp : Retrieve the module's description
        * \return moduleHelp : a structure describing the module
        */
       ALValue moduleHelp (  )
       {
         return call<ALValue>( "moduleHelp" );
       }

       /**
        * \brief openHand : Opens the hand, then cuts motor current to conserve energy.
        * \param pHandName The name of the hand. Could be: "RHand or "LHand"
        */
       void openHand ( std::string pHandName )
       {
         callVoid( "openHand", pHandName );
       }

       /**
        * \brief ping : Just a ping, with no params and returning always true
        * \return alwaysTrue : returns always true
        */
       bool ping (  )
       {
         return call<bool>( "ping" );
       }

       /**
        * \brief setAngle : Sets the angle of a joint.
        * \param pJointName Name of the Joint. Could be: "HeadYaw", "HeadPitch", "LShoulderPitch", "LShoulderRoll", "LElbowYaw", "LElbowRoll", "LWristYaw", "LHand", "LHipYawPitch", "LHipRoll", "LHipPitch", "LKneePitch", "LAnklePitch", "LAnkleRoll", "RHipYawPitch", "RHipRoll", "RHipPitch", "RKneePitch", "RAnklePitch", "RAnkleRoll", "RShoulderPitch", "RShoulderRoll", "RElbowYaw", "RElbowRoll", "RWristYaw", "RHand"
        * \param pAngle Target angle in radians.
        */
       void setAngle ( std::string pJointName, float pAngle )
       {
         callVoid( "setAngle", pJointName, pAngle );
       }

       /**
        * \brief setBalanceMode : Sets the balance mode which can be used to change the way nao responds to commands while keeping balance.
        * \param pBalanceMode Balance mode {BALANCE_MODE_OFF = 0, BALANCE_MODE_AUTO = 1, BALANCE_MODE_COM_CONTROL = 2}
        */
       void setBalanceMode ( int pBalanceMode )
       {
         callVoid( "setBalanceMode", pBalanceMode );
       }

       /**
        * \brief setBodyAngles : Sets the angles of all the joints in the body.
        * \param pAngles Vector of angles in radians for all the joints of all the chains.
        */
       void setBodyAngles ( std::vector<float>  pAngles )
       {
         callVoid( "setBodyAngles", pAngles );
       }

       /**
        * \brief setBodyStiffness : Function to set the stiffness of all the motors in the body to the same value; {0.0 : No Joint Control (the motor is in break mode) 1.0: Full joint Control (the error between Command and Sensor is as small as possible) }
        * \param pStiffness Stiffness between zero and one.
        */
       void setBodyStiffness ( float pStiffness )
       {
         callVoid( "setBodyStiffness", pStiffness );
       }

       /**
        * \brief setChainAngles : Sets the angles of the joints in the specified chain. The number of angles required depends on the length of the chain.
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \param pAngles Vector of target angles in radians.
        */
       void setChainAngles ( std::string pChainName, std::vector<float>  pAngles )
       {
         callVoid( "setChainAngles", pChainName, pAngles );
       }

       /**
        * \brief setChainStiffness : Function to set the stiffness of all the motors in the chain to the same value; {0.0 : No Joint Control (the motor is in break mode) 1.0: Full joint Control (the error between Command and Sensor is as small as possible) }
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \param pStiffness Stiffness between zero and one.
        */
       void setChainStiffness ( std::string pChainName, float pStiffness )
       {
         callVoid( "setChainStiffness", pChainName, pStiffness );
       }

       /**
        * \brief setCom : Sets the position of the Center of Mass relative to the support Leg. Units are meters.
        * \param pX x component of the COM position.
        * \param pY y component of the COM position.
        * \param pZ z component of the COM position.
        */
       void setCom ( float pX, float pY, float pZ )
       {
         callVoid( "setCom", pX, pY, pZ );
       }

       /**
        * \brief setInertialSensorEnabled : Enables or disables the use of inertial sensor while in BALANCE_MODE_AUTO
        * \param pInertialSensorEnable true if you want motion to use the intertial sensor
        */
       void setInertialSensorEnabled ( bool pInertialSensorEnable )
       {
         callVoid( "setInertialSensorEnabled", pInertialSensorEnable );
       }

       /**
        * \brief setJointSpeedParams : Sets the user parmeters for speed and acceleration control. The default values are the highest that the joint allows. The max acceleration and deceleration cannot be greater than the max speed. Hard joint limits define the max values.
        * \param pJointName The name of the joint
        * \param pUserMaxSpeed The maximum movement in radians per cycle e.g. 0.05
        * \param pUserMaxAcceleration The maximum acceleration in radians per cycle e.g. 0.006
        * \param pUserMaxDecleration The maximum deceleration in radians per cycle e.g. 0.006
        */
       void setJointSpeedParams ( std::string pJointName, float pUserMaxSpeed, float pUserMaxAcceleration, float pUserMaxDecleration )
       {
         callVoid( "setJointSpeedParams", pJointName, pUserMaxSpeed, pUserMaxAcceleration, pUserMaxDecleration );
       }

       /**
        * \brief setJointStiffness : Sets the stiffness of a joint in the body. {0.0 : No Joint Control (the motor is in break mode) 1.0: Full joint Control (the error between Command and Sensor is as small as possible) }
        * \param pJointName Name of the Joint.
        * \param pStiffness Stiffness between zero and one.
        */
       void setJointStiffness ( std::string pJointName, float pStiffness )
       {
         callVoid( "setJointStiffness", pJointName, pStiffness );
       }

       /**
        * \brief setJointStiffnesses : Sets the stiffness for a group of named joints {0.0 : No Joint Control (the motor is in break mode) 1.0: Full joint Control (the error between Command and Sensor is as small as possible) }
        * \param pJointNames A vector containing the Names of the Joints.
        * \param pStiffnesses A vector containing the Stiffnesses between zero and one.
        */
       void setJointStiffnesses ( std::vector<std::string>  pJointNames, std::vector<float>  pStiffnesses )
       {
         callVoid( "setJointStiffnesses", pJointNames, pStiffnesses );
       }

       /**
        * \brief setPosition : Moves an end-effector to the given position and orientation.
        * \param pChainName Name of the chain. Could be: "Head", "LArm","RArm", "LLeg", "RLeg"
        * \param pSpace Task space.
        * \param pPosition 6D position array (x,y,z,wx,wy,wz) in meters and radians
        * \param pAxisMask Axis mask. True for axes that you wish to control. e.g. 7 for position only, 56 for rotation only and 63 for both 
        */
       void setPosition ( std::string pChainName, int pSpace, std::vector<float>  pPosition, int pAxisMask )
       {
         callVoid( "setPosition", pChainName, pSpace, pPosition, pAxisMask );
       }

       /**
        * \brief setSupportMode : Sets the support mode.
        * \param pSupportMode Support mode. { SUPPORT_MODE_LEFT = 0, SUPPORT_MODE_DOUBLE_LEFT = 1, SUPPORT_MODE_RIGHT = 2, SUPPORT_MODE_DOUBLE_RIGHT = 3}
        */
       void setSupportMode ( int pSupportMode )
       {
         callVoid( "setSupportMode", pSupportMode );
       }

       /**
        * \brief setTorsoOrientation : Sets the Torso Orientation. Units are radians.
        * \param pTetaX The x component of the Torso Orientation along X Axis
        * \param pTetaY The y component of the Torso Orientation along Y Axis
        */
       void setTorsoOrientation ( float pTetaX, float pTetaY )
       {
         callVoid( "setTorsoOrientation", pTetaX, pTetaY );
       }

       /**
        * \brief setVerbosity : Sets the current verbosity level. A level of 2 and above will allow ALMotion to output positions in space to memory. Default 1
        * \param pVerbosityLevel 0 == LOW, 3 == HIGH
        */
       void setVerbosity ( int pVerbosityLevel )
       {
         callVoid( "setVerbosity", pVerbosityLevel );
       }

       /**
        * \brief setWalkArmsConfig : Sets the parameters that will be used for Arms next time a WalkTask is created.
        * \param pShoulderMedian the Median value of Shoulder Pitch
        * \param pShoulderAmplitude the Median value of Shoulder Pitch
        * \param pElbowMedian the Median value of Elbow Roll
        * \param pElbowAmplitude the Median value of Elbow Roll
        */
       void setWalkArmsConfig ( float pShoulderMedian, float pShoulderAmplitude, float pElbowMedian, float pElbowAmplitude )
       {
         callVoid( "setWalkArmsConfig", pShoulderMedian, pShoulderAmplitude, pElbowMedian, pElbowAmplitude );
       }

       /**
        * \brief setWalkArmsEnable : Sets if Arms Motions are enabled during the Walk Process.
        * \param pArmsEnable if true Arm Motions are controlled by the Walk Task
        */
       void setWalkArmsEnable ( bool pArmsEnable )
       {
         callVoid( "setWalkArmsEnable", pArmsEnable );
       }

       /**
        * \brief setWalkConfig : Sets the parameters that will be used next time a WalkTask is created (Use with caution).
        * \param pMaxStepLength Maximum length in meters of a footstep (0.0 to 0.09 meters).
        * \param pMaxStepHeight Maximum height of a footstep cycloid (0.0 to 0.08 meters).
        * \param pMaxStepSide Maximum side length in meters of a footstep  0.0 to 0.06 meters).
        * \param pMaxStepTurn Maximum change in z orientation in radians of a footstep (0.0 to 1.0 radians).
        * \param pHipHeight Height of the Hip during Walk Process (0.15 to 0.244 meter)
        * \param pTorsoYOrientation Define the Torso Orientation in degrees along Y axis during Walk Process (-10.0 to 10 degrees)
        */
       void setWalkConfig ( float pMaxStepLength, float pMaxStepHeight, float pMaxStepSide, float pMaxStepTurn, float pHipHeight, float pTorsoYOrientation )
       {
         callVoid( "setWalkConfig", pMaxStepLength, pMaxStepHeight, pMaxStepSide, pMaxStepTurn, pHipHeight, pTorsoYOrientation );
       }

       /**
        * \brief setWalkTrapezoidConfig : change parameter of Trapezoid
        * \param pLRollBacklashCompensator Amplitude in degrees of backlash compensation for LHipRoll (0.0 to 10.0 degrees)
        * \param pRRollBacklashCompensator Amplitude in degrees of backlash compensation for RHipRoll (-10.0 to 0.0 degrees)
        */
       void setWalkTrapezoidConfig ( float pLRollBacklashCompensator, float pRRollBacklashCompensator )
       {
         callVoid( "setWalkTrapezoidConfig", pLRollBacklashCompensator, pRRollBacklashCompensator );
       }

       /**
        * \brief stop : Stops a task using the taskID that was returned when creating the task.
        * \param pBrokerTaskID The unique BrokerTaskID that identifies the task.
        */
       void stop ( int pBrokerTaskID )
       {
         callVoid( "stop", pBrokerTaskID );
       }

       /**
        * \brief turn : Does a turn in place walk pattern that could result in several footsteps.
        * \param pAngle Angle to turn in radians e.g. 0.5.
        * \param pNumSamplesPerStep Number of 20ms cycles per step. e.g. 60.
        */
       void turn ( float pAngle, int pNumSamplesPerStep )
       {
         callVoid( "turn", pAngle, pNumSamplesPerStep );
       }

       /**
        * \brief updateInertialSensorOffset : Fixes the offset between the orientation sensed through the joints and the orientation given by the inertial sensor. Should only be used when the feet are flat on the ground.
        */
       void updateInertialSensorOffset (  )
       {
         callVoid( "updateInertialSensorOffset" );
       }

       /**
        * \brief version : Returns the revision of the module.
        * \return version_string : the string containing the version
        */
       std::string version (  )
       {
         return call<std::string>( "version" );
       }

       /**
        * \brief wait : wait end of execution method if method was called with pCall
        * \param ID ID of the method to wait
        * \param timeout timeout of the wait in ms. 0 if no timeout
        * \return timeout : True if wait exit with timeout
        */
       bool wait ( int ID, int timeout )
       {
         return call<bool>( "wait", ID, timeout );
       }

       /**
        * \brief waitMethod : wait end of execution method if method was called with pCall
        * \param name name of the method to wait
        * \param timeout timeout of the wait. 0 if no timeout
        * \return timeout : True if wait exit with timeout
        */
       int waitMethod ( std::string name, int timeout )
       {
         return call<int>( "waitMethod", name, timeout );
       }

       /**
        * \brief waitUntilWalkIsFinished : Waits until the WalkTask is finished.
        */
       void waitUntilWalkIsFinished (  )
       {
         callVoid( "waitUntilWalkIsFinished" );
       }

       /**
        * \brief walk : Walk. Will consume all walk patterns and footsteps.
        */
       void walk (  )
       {
         callVoid( "walk" );
       }

       /**
        * \brief walkArc : Does a circular walk pattern that could result in several footsteps.
        * \param pAngle Angle of the arc of the circle to turn in radians e.g. 0.5.
        * \param pRadius Radius of the circle in meters e.g. 1.5.
        * \param pNumSamplesPerStep Number of 20ms cycles per step. e.g. 60.
        */
       void walkArc ( float pAngle, float pRadius, int pNumSamplesPerStep )
       {
         callVoid( "walkArc", pAngle, pRadius, pNumSamplesPerStep );
       }

       /**
        * \brief walkIsActive : Returns true if there is an active walk task.
        * \return value : True if a walk task is active.
        */
       bool walkIsActive (  )
       {
         return call<bool>( "walkIsActive" );
       }

       /**
        * \brief walkSideways : Does a sideways walk pattern that could result in several footsteps.
        * \param pDistance Sideways distance in meters e.g. -0.1.
        * \param pNumSamplesPerStep Number of 20ms cycles per step. e.g. 60.
        */
       void walkSideways ( float pDistance, int pNumSamplesPerStep )
       {
         callVoid( "walkSideways", pDistance, pNumSamplesPerStep );
       }

       /**
        * \brief walkStraight : Does a straight walk pattern that could result in several forwards or backwards footsteps.
        * \param pDistance Distance in meters e.g. 0.1.
        * \param pNumSamplesPerStep Number of 20ms cycles per step. e.g. 60.
        */
       void walkStraight ( float pDistance, int pNumSamplesPerStep )
       {
         callVoid( "walkStraight", pDistance, pNumSamplesPerStep );
       }

     /** 
        * The type of interpolation
        */
       enum INTERPOLATION_TYPE {
         INTERPOLATION_LINEAR = 0,
         INTERPOLATION_SMOOTH = 1
       };

       /**
        * Defines the spaces within which cartesian moves can be described
        */
       enum TASK_SPACE {
         SPACE_BODY = 0,
         SPACE_SUPPORT_LEG = 1,
         //SPACE_LOCAL = 2,
         //SPACE_WORLD = 3,
         //SPACE_END = 4
       };

       /**
        * Defines the support mode of the model
        */
       enum SUPPORT_MODE {
         SUPPORT_MODE_LEFT = 0,
         SUPPORT_MODE_DOUBLE_LEFT = 1,
         SUPPORT_MODE_RIGHT = 2,
         SUPPORT_MODE_DOUBLE_RIGHT = 3,
         SUPPORT_MODE_NONE = 4,
       };

       /**
        * Defines the type of balancing to do
        */
       enum BALANCE_MODE {
         BALANCE_MODE_OFF = 0,         // no balancing
         BALANCE_MODE_AUTO = 1,        // auto create com commands
         BALANCE_MODE_COM_CONTROL = 2  // don't auto create com commands
       };

       /**
        *  Defines the axis mask
        */
       enum AXIS_MASK {
         AXIS_MASK_X = 1,
         AXIS_MASK_Y = 2, 
         AXIS_MASK_Z = 4, 
         AXIS_MASK_WX = 8,
         AXIS_MASK_WY = 16, 
         AXIS_MASK_WZ = 32,
         AXIS_MASK_ALL = 63,
         AXIS_MASK_VEL = 7,
         AXIS_MASK_ROT = 56
       };
    };
};

#endif
